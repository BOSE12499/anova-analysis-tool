<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="msapplication-navbutton-color" content="#2563eb">
    <meta name="apple-mobile-web-app-title" content="Statistics Analysis">
    <title>Statistics Analysis</title>
    
    <!-- Ultra-Modern Statistics Favicon -->
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="alternate icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3CradialGradient id='newGrad' cx='30%25' cy='30%25' r='70%25'%3E%3Cstop offset='0%25' style='stop-color:%23ff6b6b'/%3E%3Cstop offset='60%25' style='stop-color:%2345b7d1'/%3E%3Cstop offset='100%25' style='stop-color:%2396ceb4'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='47' fill='url(%23newGrad)'/%3E%3Ctext x='50' y='65' font-family='Arial,sans-serif' font-size='24' font-weight='900' text-anchor='middle' fill='white'%3EΣ%3C/text%3E%3C/svg%3E">
    
    <!-- Theme Color - Progressive Enhancement for supported browsers -->
    <script>
        // Progressive enhancement for theme-color support
        (function() {
            // Check browser support for theme-color meta tag
            const supportsThemeColor = () => {
                // Chrome, Chromium-based browsers, Edge (Chromium), Safari
                return window.chrome || 
                       /Chrome/.test(navigator.userAgent) ||
                       /Edge/.test(navigator.userAgent) ||
                       (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));
            };
            
            if (supportsThemeColor()) {
                const themeColorMeta = document.createElement('meta');
                themeColorMeta.name = 'theme-color';
                themeColorMeta.content = '#2D3748';
                document.head.appendChild(themeColorMeta);
            }
        })();
    </script>
    
    <!-- Font Awesome 6.5.1 - Latest stable version to fix SVG path issues -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer">
    
    <!-- Chart.js for interactive charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    
    <!-- html2canvas for exporting cards as images -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    
    <script>
        // Register zoom plugin globally
        if (typeof Chart !== 'undefined' && Chart.register && typeof ChartZoom !== 'undefined') {
            Chart.register(ChartZoom);
            console.log('ChartZoom plugin registered globally');
        }
        
        // Set global Chart.js font defaults to Times New Roman
        if (typeof Chart !== 'undefined') {
            Chart.defaults.font = {
                family: "'Times New Roman', Times, serif",
                size: 12,
                style: 'normal',
                weight: 'normal'
            };
            
            // Ensure all chart elements use Times New Roman
            Chart.defaults.plugins.legend.labels.font = {
                family: "'Times New Roman', Times, serif"
            };
            
            Chart.defaults.plugins.tooltip.titleFont = {
                family: "'Times New Roman', Times, serif"
            };
            
            Chart.defaults.plugins.tooltip.bodyFont = {
                family: "'Times New Roman', Times, serif"
            };
            
            Chart.defaults.scale.ticks.font = {
                family: "'Times New Roman', Times, serif"
            };
            
            console.log('Chart.js font defaults set to Times New Roman');
        }
    </script>
    
    <style>
        /* JMP-Style CSS Variables for Professional Statistical Interface */
        :root {
            /* Clean Modern Colors - Black/White/Gray Theme */
            --primary-color: #2D3748;
            --secondary-color: #6C757D;
            --accent-color: #2D3748;
            --success-color: #28A745;
            --warning-color: #FFC107;
            --error-color: #DC3545;
            
            /* Clean Black/White/Gray Theme */
            --bg-primary: #F7FAFC;        /* Very light gray background */
            --bg-secondary: #FFFFFF;      /* Pure white */
            --bg-card: #FFFFFF;           /* White cards */
            --bg-input: #FFFFFF;          /* White inputs */
            --text-primary: #1A202C;      /* Dark gray text */
            --text-secondary: #4A5568;    /* Medium gray text */
            --border-color: #E2E8F0;      /* Light gray border */
            --accent-color-alpha: rgba(45, 55, 72, 0.1);
            
            /* Modern Shadows */
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.08);
            --radius: 0px;
            --radius-lg: 0px;
            --transition: all 0.2s ease;
            
            /* Dynamic Responsive Variables */
            --screen-width: 100vw;
            --screen-height: 100vh;
            --base-font-size: 16px;
            --heading-scale: 1.0;
            --device-type: 'desktop';
            
            /* Dynamic Spacing */
            --container-padding: calc(var(--screen-width) * 0.02);
            --card-padding: calc(var(--screen-width) * 0.015);
            --element-margin: calc(var(--screen-width) * 0.01);
        }

        /* Dark Mode Theme */
        [data-theme="dark"] {
            --primary-color: #2D3748;
            --secondary-color: #8E8E93;
            --accent-color: #2D3748;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --error-color: #FF3B30;
            
            /* Dark backgrounds */
            --bg-primary: #1C1C1E;
            --bg-secondary: #2C2C2E;
            --bg-card: #2C2C2E;
            --bg-input: #3A3A3C;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --border-color: #48484A;
            --accent-color-alpha: rgba(106, 155, 220, 0.1);
            
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Fixed Header */
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-logo i {
            font-size: 1.3rem;
        }

        .header-title {
            display: none; /* Hide the subtitle completely */
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Theme toggle styles removed */

        /* Header Responsive */
        @media (max-width: 768px) {
            .header-content {
                padding: 12px 15px;
            }

            .header-logo {
                font-size: 1.5rem;
            }

            .header-logo i {
                font-size: 1.3rem;
            }

            .header-title {
                font-size: 0.9rem;
                display: none; /* Hide subtitle on mobile */
            }

            /* Theme toggle responsive styles removed */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            padding-top: 70px; /* Add padding for fixed header */
            font-size: var(--base-font-size);
            transition: var(--transition);
        }

        h1, h2, h3, h4, h5, h6, p, span, div {
            font-family: 'Times New Roman', Times, serif;
        }

        /* Dynamic Body Classes for Different Devices */
        body.mobile-xs {
            font-size: 14px;
            padding-top: 100px;
        }

        body.mobile-sm {
            font-size: 14px;
            padding-top: 95px;
        }

        body.tablet-md {
            font-size: 15px;
            padding-top: 85px;
        }

        body.tablet-lg {
            font-size: 16px;
            padding-top: 80px;
        }

        body.desktop-xl,
        body.desktop-xxl {
            font-size: 16px;
            padding-top: 80px;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            top: 0;
            left: -280px; /* Hidden by default */
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15), var(--shadow-lg);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            margin: 0;
            padding: 0;
        }

        .sidebar.open {
            left: 0 !important; /* Show sidebar - force to edge */
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-card);
        }

        .sidebar-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sidebar-content {
            padding: 20px 0;
        }

        .sidebar-menu {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar-menu-item {
            margin: 0;
        }

        .sidebar-menu-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-secondary);
            text-decoration: none;
            transition: var(--transition);
            border: 1px solid transparent;
            border-radius: 8px;
            background: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            margin: 2px 8px;
        }

        .sidebar-menu-link:hover {
            background: var(--accent-color-alpha);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .sidebar-menu-link.active {
            background: var(--accent-color-alpha);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            border-right: 3px solid var(--primary-color);
        }

        .sidebar-menu-icon {
            width: 20px;
            text-align: center;
        }

        /* Hamburger Menu Button */
        .sidebar-toggle {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--accent-color);
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin-right: 12px;
            box-shadow: 0 4px 12px rgba(45, 55, 72, 0.25);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        /* Ensure hamburger icon is visible */
        .sidebar-toggle i {
            color: var(--accent-color) !important;
            font-size: 16px !important;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
            z-index: 2;
            position: relative;
            display: block !important;
            line-height: 1 !important;
        }

        /* Alternative icon using CSS if Font Awesome fails */
        .sidebar-toggle::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 14px;
            background: 
                linear-gradient(var(--accent-color), var(--accent-color)) 0 0/100% 2px,
                linear-gradient(var(--accent-color), var(--accent-color)) 0 6px/100% 2px,
                linear-gradient(var(--accent-color), var(--accent-color)) 0 12px/100% 2px;
            background-repeat: no-repeat;
            z-index: 1;
            pointer-events: none;
        }

        /* Hide CSS fallback when Font Awesome icon is present */
        .sidebar-toggle i + .sidebar-toggle::after,
        .sidebar-toggle:has(i)::after {
            display: none;
        }

        /* Fallback for when Font Awesome doesn't load */
        .sidebar-toggle:empty::after {
            content: "☰";
            color: var(--accent-color);
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
            background: none;
            width: auto;
            height: auto;
            position: static;
            transform: none;
            display: block;
        }

        .sidebar-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-secondary) 100%);
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .sidebar-toggle:hover::before {
            opacity: 1;
        }

        .sidebar-toggle:hover {
            background: var(--accent-color);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 20px rgba(45, 55, 72, 0.4);
            border-color: var(--accent-color);
            color: white;
        }

        .sidebar-toggle:hover i {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .sidebar-toggle:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 8px rgba(45, 55, 72, 0.3);
        }

        /* Responsive adjustments for sidebar toggle */
        @media (max-width: 768px) {
            .sidebar-toggle {
                width: 40px;
                height: 40px;
                font-size: 14px;
                margin-right: 10px;
                padding: 8px;
                box-shadow: 0 3px 10px rgba(45, 55, 72, 0.25);
            }
            
            .sidebar-toggle:hover {
                transform: translateY(-1px) scale(1.02);
                box-shadow: 0 6px 16px rgba(45, 55, 72, 0.35);
            }
        }

        /* Overlay for mobile */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Adjust main content when sidebar is open (desktop) */
        .main-content {
            transition: margin-left 0.3s ease;
        }

        .main-content.shifted {
            margin-left: 280px;
        }

        /* Responsive sidebar */
        @media (max-width: 768px) {
            .sidebar {
                width: 280px; /* Keep same width as desktop for consistency */
                left: -280px; /* Match the width for complete hiding */
            }
            
            .main-content.shifted {
                margin-left: 0; /* No shift on mobile */
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: max(20px, var(--container-padding));
            padding-top: 20px; /* Remove extra top padding since body has it */
            transition: var(--transition);
        }

        /* Dynamic Container Adjustments */
        body.mobile-xs .container {
            padding: 10px 8px;
            max-width: 100%;
        }

        body.mobile-sm .container {
            padding: 12px 10px;
            max-width: 100%;
        }

        body.tablet-md .container {
            padding: 15px 12px;
            max-width: 100%;
        }

        body.tablet-lg .container {
            padding: 18px 15px;
            max-width: 1000px;
        }

        body.desktop-xl .container {
            padding: 20px;
            max-width: 1200px;
        }

        body.desktop-xxl .container {
            padding: 30px;
            max-width: 1400px;
        }

        /* JMP-Style Header - Clean, Professional */
        .header {
            text-align: center;
            margin-bottom: 24px;
        }

        .header h1 {
            font-size: calc(2rem * var(--heading-scale));
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 6px;
            transition: var(--transition);
        }

        .header .subtitle {
            font-size: calc(1rem * var(--heading-scale));
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
            white-space: nowrap;
            transition: var(--transition);
        }

        /* Dynamic Header Adjustments */
        body.mobile-xs .header h1 {
            font-size: 1.6rem;
            line-height: 1.2;
        }

        body.mobile-xs .header .subtitle {
            font-size: 0.85rem;
            white-space: normal;
            max-width: none;
        }

        body.mobile-sm .header h1 {
            font-size: 1.8rem;
        }

        body.mobile-sm .header .subtitle {
            font-size: 0.9rem;
            white-space: normal;
        }

        body.tablet-md .header h1 {
            font-size: 2rem;
        }

        body.tablet-md .header .subtitle {
            font-size: 1rem;
        }

        body.tablet-lg .header h1 {
            font-size: 2.2rem;
        }

        body.desktop-xxl .header h1 {
            font-size: 2.8rem;
        }

        body.desktop-xxl .header .subtitle {
            font-size: 1.2rem;
        }

        /* JMP-Style Cards - Clean, Flat Design */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: max(20px, var(--card-padding));
            margin-bottom: max(20px, var(--element-margin));
            box-shadow: none;
            transition: var(--transition);
        }

        .card:hover {
            border-color: var(--accent-color);
            box-shadow: var(--shadow);
        }

        /* Dynamic Card Adjustments */
        body.mobile-xs .card {
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 8px;
        }

        body.mobile-sm .card {
            padding: 16px;
            margin-bottom: 14px;
        }

        body.tablet-md .card {
            padding: 18px;
            margin-bottom: 16px;
        }

        body.tablet-lg .card {
            padding: 20px;
            margin-bottom: 18px;
        }

        body.desktop-xl .card {
            padding: 24px;
            margin-bottom: 24px;
        }

        body.desktop-xxl .card {
            padding: 28px;
            margin-bottom: 28px;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 24px;
            position: relative;
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--accent-color);
            background: rgba(14, 165, 233, 0.05);
        }

        /* Prevent double clicks on upload area */
        .upload-area .btn {
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        .upload-icon {
            font-size: 2.5rem;
            color: var(--accent-color);
            margin-bottom: 12px;
        }

        .upload-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        /* Input Tabs */
        .input-tabs {
            display: flex;
            margin-bottom: 24px;
            border-bottom: 2px solid var(--border-color);
        }

        .tab-button {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Times New Roman', Times, serif;
            border-radius: 8px 8px 0 0;
            margin-right: 4px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button:hover {
            background: var(--accent-color);
            color: white;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            border-bottom: 2px solid var(--primary-color);
        }

        .input-tab {
            display: none;
        }

        .input-tab.active {
            display: block;
        }

        /* Text Input Area */
        .text-input-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            padding: 24px;
            text-align: center;
        }

        .format-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 16px 0;
            flex-wrap: wrap;
        }

        .format-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .format-option input[type="radio"] {
            accent-color: var(--primary-color);
        }

        #dataTextArea {
            width: 100%;
            min-height: 300px;
            padding: 16px 16px 16px 0; /* ลบ padding ซ้ายออกเลย (0px) */
            border: 2px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            resize: vertical;
            margin: 16px 0;
            white-space: nowrap;
            overflow-x: auto;
            overflow-y: auto;
            text-indent: 0 !important; /* บังคับไม่ให้เยื้องข้อความ */
            text-align: left !important; /* บังคับให้ข้อความชิดซ้าย */
            padding-left: 0 !important; /* บังคับให้ไม่มี padding ซ้าย */
            margin-left: 0 !important; /* บังคับไม่ให้มี margin ซ้าย */
            box-sizing: border-box;
        }

        #dataTextArea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .text-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .data-preview {
            margin-top: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .data-preview.hidden {
            display: none;
        }

        .data-preview h4 {
            margin-bottom: 12px;
            color: var(--accent-color);
        }

        .preview-table {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .preview-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .stat-item {
            background: var(--bg-primary);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Responsive adjustments for text input */
        @media (max-width: 768px) {
            .format-options {
                flex-direction: column;
                gap: 12px;
            }
            
            .text-controls {
                flex-direction: column;
            }
        }

        .upload-subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 16px;
        }

        /* JMP-Style Buttons - Clean, Professional */
        .btn {
            background: var(--primary-color);
            color: white;
            border: 1px solid var(--primary-color);
            padding: 8px 16px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            font-family: 'Times New Roman', Times, serif;
            transition: var(--transition);
            box-shadow: none;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .btn:hover:not(:disabled) {
            background: #1A202C;
            border-color: #1A202C;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Dynamic Button Adjustments */
        body.mobile-xs .btn {
            font-size: 0.75rem;
            padding: 8px 12px;
            min-height: 36px;
            gap: 4px;
        }

        body.mobile-sm .btn {
            font-size: 0.8rem;
            padding: 9px 14px;
            min-height: 38px;
            gap: 5px;
        }

        body.tablet-md .btn {
            font-size: 0.85rem;
            padding: 10px 16px;
            min-height: 40px;
        }

        body.tablet-lg .btn {
            font-size: 0.9rem;
            padding: 11px 20px;
            min-height: 42px;
        }

        body.desktop-xl .btn {
            font-size: 0.95rem;
            padding: 12px 24px;
            min-height: 44px;
        }

        body.desktop-xxl .btn {
            font-size: 1rem;
            padding: 14px 28px;
            min-height: 48px;
        }

        .btn-accent {
            background: var(--accent-color);
        }

        .btn-accent:hover:not(:disabled) {
            background: #1A202C;
        }


        /* Secondary Button (Export) */
        .btn-secondary {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            box-shadow: var(--shadow);
        }
        .btn-secondary:hover:not(:disabled) {
            background: var(--accent-color);
            color: white;
            box-shadow: var(--shadow-lg);
        }

        .btn-export {
            background: var(--success-color);
            color: white;
        }

        .btn-export:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .btn-export-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-export-card:hover {
            background: linear-gradient(135deg, #5a6fd6 0%, #6a4190 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-export-card:active {
            transform: translateY(0);
        }

        .btn-export-card:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .dashboard-action {
            animation: slideInUp 0.5s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Input Groups */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .input-group {
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .input-helper-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 4px;
            display: block;
        }

        .input-group input[type="number"] {
            width: 100%;
            max-width: 200px;
            padding: 6px 8px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: var(--transition);
        }

        .input-group input[type="text"] {
            width: 100%;
            max-width: 400px;
            padding: 8px 12px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: var(--transition);
        }

        .input-group input[type="number"]:focus,
        .input-group input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: none;
        }

        /* JMP-Style Table Names Section */
        .table-names-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 16px;
            margin: 16px 0;
            box-shadow: none;
        }

        .table-names-section h3 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .table-names-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .table-names-section-compact {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-top: 8px;
            margin-bottom: 20px;
        }

        .compact-suffix-input {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .compact-suffix-input label {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin: 0;
            font-weight: 500;
        }

        .suffix-input-compact {
            width: 100%;
            max-width: 400px;
            padding: 8px 12px;
            font-size: 0.9rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            transition: border-color 0.2s ease;
        }

        .suffix-input-compact:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-color-alpha);
        }

        .suffix-input-compact::placeholder {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .name-input-group {
            display: flex;
            flex-direction: column;
        }

        .name-input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .name-input-group input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: var(--transition);
        }

        .name-input-group input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: none;
        }

        .name-input-group input[type="text"]::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        /* JMP-Style Sample Section */
        .sample-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 16px;
            margin-top: 16px;
            margin-bottom: 16px;
        }

        .sample-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sample-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 768px) {
            .sample-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        .sample-example,
        .sample-tips {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 16px;
            box-shadow: var(--shadow);
        }

        .pre-formatted {
            font-family: 'Courier New', monospace;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 12px;
            white-space: pre;
            font-size: 0.85rem;
            color: var(--text-secondary);
            overflow-x: auto;
        }

        /* Basic Information Table Styles - Now using standard table format 
        .basic-info-table {
            width: 100%;
            margin-bottom: 16px;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: var(--bg-card);
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: none;
            border: 1px solid var(--border-color);
        }

        .info-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            vertical-align: middle;
            transition: background-color 0.2s ease;
        }

        .info-table tr:last-child td {
            border-bottom: none;
        }

        .info-table tr:nth-child(odd) {
            background: #FFFFFF;
        }
        
        .info-table tr:nth-child(even) {
            background: #F8F9FA;
        }

        .info-table tr:hover {
            background: #E2E8F0 !important;
            transition: all 0.3s ease;
        }

        .info-label {
            background: var(--bg-secondary);
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            min-width: 160px;
            width: 40%;
            border-right: 2px solid var(--border-color);
            position: relative;
        }

        .info-label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
            border-radius: 0 1px 1px 0;
        }

        .info-label i {
            margin-right: 8px;
            color: #2D3748;
            font-size: 0.9rem;
            width: 16px;
            text-align: center;
        }

        .info-value {
            color: var(--text-primary);
            font-family: 'Times New Roman', Times, serif;
            font-weight: 500;
            font-size: 0.8rem;
            background: var(--bg-card);
            padding-left: 16px;
        }

        /* ปรับสีให้อ่อนลงสำหรับ LOT count rows */
        .info-table tr:nth-child(n+4) .info-label {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-right-color: var(--border-color);
        }

        .info-table tr:nth-child(n+4) .info-label::before {
            background: var(--border-color);
        }

        .info-table tr:nth-child(n+4) .info-label i {
            color: #2D3748;
        }

        .info-table tr:nth-child(n+4) .info-value {
            background: var(--bg-card);
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Enhanced visual hierarchy แบบกะทัดรัด */
        .info-table tr:first-child td {
            padding-top: 12px;
        }

        .info-table tr:last-child td {
            padding-bottom: 12px;
        }

        /* Add subtle animations */
        .info-table {
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive enhancements - ขนาดเล็ก */
        @media (max-width: 768px) {
            .info-table td {
                padding: 8px 12px;
                font-size: 0.75rem;
            }

            .info-label {
                min-width: 120px;
                width: 45%;
                font-size: 0.7rem;
            }

            .info-label i {
                margin-right: 6px;
                font-size: 0.8rem;
            }

            .info-value {
                padding-left: 12px;
                font-size: 0.75rem;
            }
        }
        */

        .tips-list {
            list-style-type: none;
            padding-left: 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .tips-list li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 20px;
        }

        .tips-list li:before {
            content: '✓';
            position: absolute;
            left: 0;
            color: var(--success-color);
            font-weight: bold;
        }

        /* Enhanced Results Section */
        .results-section {
            display: none;
            margin-top: 40px;
        }

        .results-section.visible {
            display: block;
            animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideInUp {
            from { 
                opacity: 0; 
                transform: translateY(60px) scale(0.95);
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1);
            }
        }

        /* JMP-Style Result Cards */
        .result-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-color);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
            transition: var(--transition);
            position: relative;
            overflow: visible;
        }

        .result-card:hover {
            border-color: var(--accent-color);
            box-shadow: var(--shadow-lg);
        }
        
        .result-card h3 {
            color: var(--text-primary);
            margin-bottom: 16px;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .result-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.9rem;
        }
        
        .result-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-color);
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px 20px;
        }
        
        .loading-text {
            color: var(--text-secondary);
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 16px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Analyze Section with Inline Loading */
        .analyze-section {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .loading-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #F8FDF8;
            border: 1px solid #D4EDDA;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.1);
            animation: fadeInSlideRight 0.4s ease-out;
        }

        .loading-inline.hidden {
            display: none;
        }

        .spinner-inline {
            width: 20px;
            height: 20px;
            border: 2px solid #E8F5E8;
            border-top: 2px solid #28A745;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        .loading-text-inline {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .loading-title {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .loading-subtitle {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Progress Bar Styles */
        .progress-bar-container {
            width: 100%;
            height: 3px;
            background-color: #E8F5E8;
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #28A745;
            border-radius: 2px;
            width: 0%;
            animation: progressAnimation 2s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }

        @keyframes progressAnimation {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }

        /* Indeterminate Progress Animations */
        @keyframes indeterminateProgress {
            0% { 
                background-position: -200px 0;
                width: 30%;
                margin-left: 0%;
            }
            50% { 
                background-position: 0px 0;
                width: 70%;
                margin-left: 15%;
            }
            100% { 
                background-position: 200px 0;
                width: 30%;
                margin-left: 70%;
            }
        }

        @keyframes indeterminatePulse {
            0%, 100% { 
                opacity: 0.6;
                transform: scaleX(0.8);
            }
            50% { 
                opacity: 1;
                transform: scaleX(1.1);
            }
        }

        @keyframes indeterminateSlide {
            0% { 
                transform: translateX(-100%);
                width: 50%;
            }
            100% { 
                transform: translateX(300%);
                width: 50%;
            }
        }

        @keyframes fadeInSlideRight {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Responsive design for analyze section */
        @media (max-width: 768px) {
            .analyze-section {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .loading-inline {
                justify-content: center;
                padding: 6px 10px;
            }
            
            .loading-title {
                font-size: 0.7rem;
            }
            
            .loading-subtitle {
                font-size: 0.65rem;
            }
            
            .progress-bar-container {
                margin-top: 4px;
                height: 2px;
            }
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            margin: 16px 0;
            border-radius: 0px;
            border: 1px solid var(--border-color);
        }

        /* JMP-Style Statistical Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            font-family: 'Times New Roman', Times, serif;
            border: 1px solid var(--border-color);
        }

        th, td {
            padding: 6px 12px;
            text-align: left;
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: #E2E8F0;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
            text-transform: none;
            letter-spacing: normal;
        }

        /* JMP-style alternating row colors */
        tbody tr:nth-child(odd) {
            background: #FFFFFF;
        }
        
        tbody tr:nth-child(even) {
            background: #F8F9FA;
        }

        tr:hover {
            background: #E2E8F0 !important;
        }

        /* Icon styling for Basic Information table */
        table tbody td i {
            margin-right: 8px;
            color: #2D3748;
            font-size: 0.9rem;
            width: 16px;
            text-align: center;
        }

        /* Compact Table for Confidence Quantile - สไตล์เหมือนตารางอื่นๆ */
        .compact-table-container {
            margin: 16px 0;
            border: 1px solid var(--border-color);
            border-radius: 0px;
            display: inline-block;
            min-width: 250px;
            max-width: 300px;
            background: var(--bg-card);
        }

        .compact-quantile-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: transparent;
        }

        .compact-quantile-table th {
            background: #E2E8F0;
            color: var(--text-primary);
            padding: 6px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: none;
            letter-spacing: normal;
        }

        .compact-quantile-table td {
            padding: 6px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            font-family: 'Times New Roman', Times, serif;
            color: var(--text-primary);
        }

        .compact-quantile-table tbody tr:nth-child(odd) {
            background: #FFFFFF;
        }
        
        .compact-quantile-table tbody tr:nth-child(even) {
            background: #F8F9FA;
        }

        .compact-quantile-table tbody tr:hover {
            background: #E2E8F0 !important;
        }

        /* Charts */
        .chart-container {
            margin: 16px 0;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .chart-container img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius);
        }

        /* Zoom Controls */
        .chart-zoom-controls {
            display: flex;
            gap: 2px; /* ลด gap จาก 5px เป็น 2px */
            flex-direction: column;
            background: rgba(255, 255, 255, 0.05); /* พื้นหลังโปร่งใสเล็กน้อย */
            border-radius: 6px;
            padding: 4px; /* เพิ่ม padding เล็กน้อย */
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 24px;  /* ลดขนาดจาก 36px เป็น 24px */
            height: 24px; /* ลดขนาดจาก 36px เป็น 24px */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px; /* ลดขนาดฟอนต์จาก 14px เป็น 10px */
            color: var(--text-primary);
            transition: all 0.2s ease;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* ลดเงาให้เล็กลง */
        }

        .zoom-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.05); /* ลดการขยายจาก 1.1 เป็น 1.05 */
        }

        .zoom-btn:active {
            transform: scale(0.98); /* ลดการหดตัวจาก 0.95 เป็น 0.98 */
        }

        /* Messages */
        .message {
            padding: 12px 16px;
            border-radius: var(--radius);
            margin: 12px 0;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .success {
            background: rgba(16, 185, 129, 0.1);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .warning {
            background: rgba(245, 158, 11, 0.1);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        /* Interpretation */
        .interpretation {
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid rgba(37, 99, 235, 0.3);
            color: var(--text-primary);
            padding: 16px;
            border-radius: var(--radius);
            margin: 16px 0;
        }

        .interpretation h4 {
            margin-bottom: 8px;
            font-size: 1rem;
            color: var(--accent-color);
        }

        /* File Display */
        #fileNameDisplay {
            margin-top: 12px;
            font-weight: 500;
            color: var(--accent-color);
            font-size: 0.9rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            .card {
                padding: 16px;
                margin-bottom: 16px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .upload-area {
                padding: 24px 12px;
            }

            .btn {
                width: 100%;
                margin-bottom: 12px;
            }

            .input-group input[type="number"] {
                max-width: 100%;
            }

            .input-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            /* Fixed Header */
            .fixed-header {
                padding: 10px 0;
            }

            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }

            .header-logo {
                margin-bottom: 8px;
            }

            .header-title {
                display: block;
                font-size: 0.9rem;
                text-align: center;
            }

            .header-right {
                width: 100%;
                justify-content: space-between;
                margin-top: 8px;
            }

            /* Theme toggle responsive removed */
        }

        /* Enhanced Responsive Design for All Devices - Same as dashboard.html */
        
        /* Extra Large Desktops (1400px+) */
        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
                padding: 30px;
            }
            
            .upload-section,
            .results-section {
                padding: 30px;
            }
        }

        /* Large Desktops (1200px - 1399px) */
        @media (min-width: 1200px) and (max-width: 1399px) {
            .container {
                max-width: 1200px;
            }
            
            .upload-section,
            .results-section {
                padding: 25px;
            }
        }

        /* Tablets Landscape & Small Laptops (992px - 1199px) */
        @media (min-width: 992px) and (max-width: 1199px) {
            .header-content {
                padding: 8px 15px;
            }
            
            .header-logo {
                font-size: 1.4rem;
            }
            
            .container {
                padding: 20px 15px;
            }
            
            .upload-section,
            .results-section {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .btn {
                font-size: 0.8rem;
                padding: 7px 14px;
            }
        }

        /* Tablets Portrait (768px - 991px) */
        @media (min-width: 768px) and (max-width: 991px) {
            body {
                padding-top: 90px;
            }
            
            .header-content {
                flex-wrap: wrap;
                gap: 10px;
                padding: 12px 15px;
            }
            
            .header-logo {
                font-size: 1.5rem;
            }
            
            .container {
                padding: 15px 12px;
            }
            
            .upload-section,
            .results-section {
                padding: 18px;
                margin-bottom: 18px;
            }
            
            .btn {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .sample-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        /* Mobile Landscape (576px - 767px) */
        @media (min-width: 576px) and (max-width: 767px) {
            body {
                padding-top: 100px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 10px;
                padding: 12px 15px;
                align-items: center;
            }
            
            .header-logo {
                font-size: 1.3rem;
                text-align: center;
            }
            
            .header-title {
                display: block;
                text-align: center;
                font-size: 0.85rem;
            }
            
            .header-right {
                width: 100%;
                justify-content: center;
            }
            
            .container {
                padding: 15px 10px;
            }
            
            .upload-section,
            .results-section {
                padding: 16px;
                margin-bottom: 16px;
            }
            
            .btn {
                font-size: 0.75rem;
                padding: 5px 10px;
                gap: 4px;
            }
            
            .sample-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        /* Mobile Portrait (up to 575px) */
        @media (max-width: 575px) {
            body {
                padding-top: 110px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 12px;
                padding: 15px 10px;
                align-items: center;
            }
            
            .header-logo {
                font-size: 1.2rem;
                text-align: center;
            }
            
            .header-logo i {
                font-size: 1.1rem;
            }
            
            .header-title {
                display: block;
                text-align: center;
                font-size: 0.8rem;
                margin-top: -5px;
            }
            
            /* Theme toggle responsive removed */
            
            .container {
                padding: 12px 8px;
            }
            
            .upload-section,
            .results-section {
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 8px;
            }
            
            .section-header h2 {
                font-size: 1.3rem;
                text-align: center;
            }
            
            .section-header p {
                font-size: 0.85rem;
                text-align: center;
                margin-bottom: 15px;
            }
            
            .btn {
                font-size: 0.7rem;
                padding: 4px 8px;
                gap: 3px;
                min-height: 36px;
            }
            
            .btn i {
                font-size: 0.7rem;
            }
            
            .sample-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .sample-example,
            .sample-tips {
                padding: 12px;
            }
            
            .pre-formatted {
                padding: 10px;
                font-size: 0.8rem;
                overflow-x: auto;
            }

            /* Mobile styles สำหรับ Basic Information Table ขนาดเล็ก */
            .info-table {
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
            }

            .info-table td {
                padding: 8px 12px;
                font-size: 0.75rem;
            }

            .info-label {
                min-width: 120px;
                width: 45%;
                font-size: 0.7rem;
                letter-spacing: 0.5px;
                background: var(--bg-secondary);
            }

            .info-label i {
                margin-right: 6px;
                font-size: 0.8rem;
                width: 14px;
            }

            .info-value {
                padding-left: 12px;
                font-size: 0.75rem;
                background: var(--bg-card);
            }

            /* ปรับสีสำหรับ mobile - ใช้สีปกติ */
            .info-table tr:nth-child(n+4) .info-label {
                background: var(--bg-secondary);
                color: var(--text-primary);
            }

            .info-table tr:nth-child(n+4) .info-value {
                background: var(--bg-card);
                color: var(--text-primary);
            }
            
            .tips-list {
                font-size: 0.85rem;
            }
            
            .tips-list li {
                margin-bottom: 6px;
                padding-left: 18px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn:hover,
            .upload-section:hover {
                transform: none;
            }
            
            .btn:active,
            .upload-section:active {
                transform: scale(0.98);
            }
            
            /* Larger touch targets */
            .btn {
                min-height: 44px;
                padding: 8px 16px;
            }
        }

        /* Print styles */
        @media print {
            body {
                padding-top: 0;
            }
            
            .fixed-header {
                position: static;
                box-shadow: none;
                border-bottom: 2px solid #000;
                margin-bottom: 20px;
            }
            
            /* Theme toggle removed */
            
            .upload-section,
            .results-section {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ccc;
            }
        }

        /* Ultra-wide screens (1600px+) */
        @media (min-width: 1600px) {
            .container {
                max-width: 1600px;
                padding: 40px;
            }
            
            .upload-section,
            .results-section {
                padding: 35px;
            }
        }

        /* Force light theme always */
        html, html[data-theme="light"], html[data-theme="dark"] {
            color-scheme: light;
        }

        /* Hidden elements */
        .hidden {
            display: none;
        }

        .file-input {
            display: none;
        }

        /* Utility classes for inline styles */
        .dashboard-action-layout {
            margin-top: 20px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 12px;
            position: relative;
            z-index: 10;
        }
        
        .dashboard-action-layout button {
            pointer-events: auto !important;
            z-index: 20 !important;
            position: relative !important;
        }

        .btn-min-width-180 {
            min-width: 180px;
            position: relative;
            z-index: 15;
        }

        .btn-min-width-120 {
            min-width: 120px;
            position: relative;
            z-index: 15;
        }

        .margin-top-10 {
            margin-top: 10px;
        }

        .margin-bottom-10 {
            margin-bottom: 10px;
        }

        .margin-bottom-15 {
            margin-bottom: 15px;
        }

        .text-small {
            font-size: 0.9em;
            color: #555;
        }



        .text-primary-color {
            color: var(--text-primary);
        }

        .monospace-table {
            font-family: monospace;
            font-size: 0.9em;
            border-collapse: collapse;
        }

        .table-header-cell {
            text-align: left;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .table-header-center {
            text-align: center;
            background: var(--bg-secondary);
            color: var(--text-primary);
            min-width: 100px;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .table-cell-bold {
            font-weight: bold;
            background: var(--bg-secondary);
            color: var(--text-primary);
            text-align: left;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .error-header {
            background: var(--error-color);
            color: white;
        }

        .error-cell {
            color: var(--error-color);
            text-align: center;
            padding: 20px;
        }

        .significant-row {
            background-color: #fff3cd;
        }

        .cell-significant {
            background: #dc3545;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .cell-normal {
            background: var(--bg-card);
            color: var(--text-primary);
            text-align: center;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .cell-error {
            background: var(--error-color);
            color: white;
            text-align: center;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        /* Simple Footer Styles */
        .simple-footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            margin-top: 2rem;
            padding: 1rem 0;
            text-align: center;
        }

        .footer-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .simple-footer p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin: 0;
        }



        /* Footer Responsive Design */
        @media (max-width: 480px) {
            .simple-footer {
                margin-top: 1.5rem;
                padding: 0.75rem 0;
            }
            
            .simple-footer p {
                font-size: 0.8rem;
            }
        }


    </style>
</head>
<body>
    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3>
                <i class="fas fa-chart-line"></i>
                Menu
            </h3>
        </div>
        <div class="sidebar-content">
            <nav>
                <ul class="sidebar-menu">
                    <li class="sidebar-menu-item">
                        <button class="sidebar-menu-link active" id="homeMenu">
                            <span>HOME</span>
                        </button>
                    </li>
                    <li class="sidebar-menu-item">
                        <button class="sidebar-menu-link" id="dashboardMenu">
                            <span>Dashboard</span>
                        </button>
                    </li>
                    <li class="sidebar-menu-item">
                        <button class="sidebar-menu-link" id="exportMenu">
                            <span>Export</span>
                        </button>
                    </li>

                </ul>
            </nav>
        </div>
    </aside>

    <!-- Fixed Header -->
    <div class="fixed-header">
        <div class="header-content">
            <div class="header-left">
                <!-- Sidebar Toggle Button inside header -->
                <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle Sidebar">
                </button>
                <a href="#" class="header-logo">
                    Statistics Analysis
                </a>
            </div>
            <div class="header-right">

            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content" id="mainContent">
        <div class="container">
            <div class="header">
                <h1>Statistics Analysis</h1>
            </div>

        <div class="card">
            <!-- Input Method Tabs -->
            <div class="input-tabs">
                <button class="tab-button active" onclick="switchInputMethod('csv')" id="csvTabBtn">
                    CSV Upload
                </button>
                <button class="tab-button" onclick="switchInputMethod('text')" id="textTabBtn">
                    Copy & Paste
                </button>
            </div>

            <!-- CSV Upload Tab -->
            <div id="csvInputTab" class="input-tab active">
                <div class="upload-area" id="uploadArea">
                    <h3 class="upload-title">Upload Dataset</h3>
                    <p class="upload-subtitle">
                        Drop CSV file here or click to browse<br>
                        <small>Format: Column A (LOT names), Column B (Numeric data)</small>
                    </p>
                    <input type="file" id="fileInput" class="file-input" accept=".csv">
                    <button class="btn" id="chooseFileBtn">
                        Choose File
                    </button>
                    <p id="fileNameDisplay"></p>
                </div>
            </div>

            <!-- Text Input Tab -->
            <div id="textInputTab" class="input-tab">
                <div class="text-input-area">
                    <textarea 
                        id="dataTextArea" 
                        placeholder="Paste your data here, example:
LOT1 10.2
LOT1 11.5
LOT2 12.1
LOT2 11.8
LOT3 9.8
LOT3 9.5
LOT4 13.2
LOT4 12.9

Each line: LOT_name numeric_value (space-separated)"
                        rows="12">
                    </textarea>
                    
                    <div id="textDataPreview" class="data-preview hidden">
                        <h4>Data Preview:</h4>
                        <div id="previewTable"></div>
                        <div id="previewStats"></div>
                    </div>
                </div>
            </div>

            <div class="sample-section">
                <div class="sample-title">
                    Sample CSV Format
                </div>
                <div class="sample-grid">
                    <div class="sample-example">
                        <h5>Your CSV should look like this:</h5>
                        <div class="pre-formatted">LOT1,10.2
LOT1,11.5
LOT2,12.1
LOT2,11.8
LOT3,9.8
LOT3,9.5</div>
                    </div>
                    <div class="sample-tips">
                        <h5>Quick Tips:</h5>
                        <ul class="tips-list">
                            <li>Column A: LOT names (text)</li>
                            <li>Column B: Numeric data</li>
                            <li>No headers needed</li>
                            <li>At least 2 groups required</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="input-grid">
                <div class="input-group">
                    <label for="slideTitleInput">
                        <i class="fas fa-heading"></i> PowerPoint Slide Title
                    </label>
                    <input type="text" id="slideTitleInput" placeholder="Enter custom title (default: Statistic comparison result)" maxlength="100">
                </div>
            </div>

            <div class="input-grid">
                <div class="input-group">
                    <label for="lsl">Lower Spec Limit (LSL)</label>
                    <input type="number" id="lsl" placeholder="e.g., 9.0" step="any">
                </div>
                <div class="input-group">
                    <label for="usl">Upper Spec Limit (USL)</label>
                    <input type="number" id="usl" placeholder="e.g., 13.0" step="any">
                </div>
            </div>

            <div class="analyze-section">
                <button id="analyzeBtn" class="btn btn-accent">
                    Perform Analysis
                </button>
                
                <div id="loadingDiv" class="loading-inline hidden">
                    <div class="spinner-inline"></div>
                    <div class="loading-text-inline">
                        <span class="loading-title">Processing Statistical Analysis...</span>
                        <span class="loading-subtitle">Please wait while we analyze your data</span>
                        <div class="progress-bar-container">
                            <div class="progress-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="resultsSection" class="results-section">
            <!-- Results content will be shown here -->

            <div id="resultsContent" class="hidden">

            </div>
        </div>
    </div>

    <script>
        // Error handling wrapper
        window.addEventListener('error', function(e) {
            console.error('❌ Global JavaScript Error:', e.error);
            console.error('Error details:', {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno,
                stack: e.error?.stack
            });
        });

        // Promise rejection handler
        window.addEventListener('unhandledrejection', function(e) {
            console.error('❌ Unhandled Promise Rejection:', e.reason);
        });

        console.log('🔥 JavaScript loaded successfully');
        console.log('🔍 Current location:', window.location.href);

        // Global variables
        let csvFile = null;
        let csvFileContent = null;
        let resizeTimeout;
        let currentDeviceType = 'desktop';
        
        // DOM element references - will be initialized after DOM loads
        let uploadArea, fileInput, analyzeBtn, fileNameDisplay, resultsSection, loadingDiv, resultsContent;
        
        console.log('🌍 Global variables initialized');

        // Dynamic Device Detection and Responsive Adjustments
        function detectDeviceTypeAndApplyStyles() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const orientation = width > height ? 'landscape' : 'portrait';
            
            let deviceType = 'desktop';
            let deviceClass = '';
            
            if (width <= 575) {
                deviceType = 'mobile-portrait';
                deviceClass = 'mobile-xs';
            } else if (width <= 767) {
                deviceType = 'mobile-landscape';
                deviceClass = 'mobile-sm';
            } else if (width <= 991) {
                deviceType = 'tablet-portrait';
                deviceClass = 'tablet-md';
            } else if (width <= 1199) {
                deviceType = 'tablet-landscape';
                deviceClass = 'tablet-lg';
            } else if (width <= 1399) {
                deviceType = 'desktop';
                deviceClass = 'desktop-xl';
            } else {
                deviceType = 'desktop-large';
                deviceClass = 'desktop-xxl';
            }
            
            // Apply device-specific classes to body
            document.body.className = document.body.className.replace(/\b(mobile-xs|mobile-sm|tablet-md|tablet-lg|desktop-xl|desktop-xxl)\b/g, '');
            document.body.classList.add(deviceClass);
            
            // Set CSS custom properties for dynamic sizing
            const root = document.documentElement;
            root.style.setProperty('--screen-width', width + 'px');
            root.style.setProperty('--screen-height', height + 'px');
            root.style.setProperty('--device-type', deviceType);
            root.setAttribute('data-device', deviceType);
            root.setAttribute('data-orientation', orientation);
            
            // Dynamic font scaling
            if (width <= 575) {
                root.style.setProperty('--base-font-size', '14px');
                root.style.setProperty('--heading-scale', '0.8');
            } else if (width <= 767) {
                root.style.setProperty('--base-font-size', '15px');
                root.style.setProperty('--heading-scale', '0.9');
            } else if (width <= 991) {
                root.style.setProperty('--base-font-size', '16px');
                root.style.setProperty('--heading-scale', '1.0');
            } else {
                root.style.setProperty('--base-font-size', '16px');
                root.style.setProperty('--heading-scale', '1.0');
            }
            
            // Trigger layout recalculation if device type changed
            if (currentDeviceType !== deviceType) {
                currentDeviceType = deviceType;
                adjustLayoutForDevice();
                console.log(`📱 Device changed to: ${deviceType} (${width}x${height})`);
            }
            
            return { deviceType, orientation, width, height };
        }

        // Adjust specific elements based on device
        function adjustLayoutForDevice() {
            const deviceInfo = detectDeviceTypeAndApplyStyles();
            
            // Adjust button sizes
            const buttons = document.querySelectorAll('.btn');
            buttons.forEach(btn => {
                if (deviceInfo.width <= 575) {
                    btn.style.fontSize = '0.75rem';
                    btn.style.padding = '8px 12px';
                } else if (deviceInfo.width <= 767) {
                    btn.style.fontSize = '0.8rem';
                    btn.style.padding = '9px 14px';
                } else {
                    btn.style.fontSize = '';
                    btn.style.padding = '';
                }
            });
            
            // Adjust container padding
            const container = document.querySelector('.container');
            if (container) {
                if (deviceInfo.width <= 575) {
                    container.style.padding = '10px 8px';
                } else if (deviceInfo.width <= 767) {
                    container.style.padding = '15px 10px';
                } else {
                    container.style.padding = '';
                }
            }
            
            // Adjust cards
            const cards = document.querySelectorAll('.card, .result-card');
            cards.forEach(card => {
                if (deviceInfo.width <= 575) {
                    card.style.padding = '15px';
                    card.style.marginBottom = '12px';
                } else if (deviceInfo.width <= 767) {
                    card.style.padding = '18px';
                    card.style.marginBottom = '15px';
                } else {
                    card.style.padding = '';
                    card.style.marginBottom = '';
                }
            });
            
            // Adjust tables for mobile
            const tables = document.querySelectorAll('table');
            tables.forEach(table => {
                if (deviceInfo.width <= 767) {
                    table.style.fontSize = '0.75rem';
                    const cells = table.querySelectorAll('th, td');
                    cells.forEach(cell => {
                        cell.style.padding = '6px 8px';
                    });
                } else {
                    table.style.fontSize = '';
                    const cells = table.querySelectorAll('th, td');
                    cells.forEach(cell => {
                        cell.style.padding = '';
                    });
                }
            });
        }

        // Debounced resize handler
        function handleResize() {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            
            resizeTimeout = setTimeout(() => {
                const deviceInfo = detectDeviceTypeAndApplyStyles();
                
                // Show resize notification for debugging - DISABLED
                // console.log(`🔄 Resized to: ${deviceInfo.width}x${deviceInfo.height} (${deviceInfo.deviceType})`);
                
                // Visual feedback for responsive changes - DISABLED
                // if (typeof showNotification === 'function') {
                //     showNotification(`📱 Layout adjusted for ${deviceInfo.deviceType.replace('-', ' ')} (${deviceInfo.width}px wide)`, 'info');
                // }
                
                // Add visual indicator to body
                document.body.setAttribute('data-responsive-info', `${deviceInfo.deviceType} ${deviceInfo.width}x${deviceInfo.height}`);
            }, 150);
        }



        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            

            
            // Initialize DOM element references
            uploadArea = document.getElementById('uploadArea');
            fileInput = document.getElementById('fileInput');
            analyzeBtn = document.getElementById('analyzeBtn');
            fileNameDisplay = document.getElementById('fileNameDisplay');
            resultsSection = document.getElementById('resultsSection');
            loadingDiv = document.getElementById('loadingDiv');
            resultsContent = document.getElementById('resultsContent');
            
            // Text input elements
            const dataTextArea = document.getElementById('dataTextArea');
            const processTextBtn = document.getElementById('processTextBtn');
            
            // Check if critical elements exist
            const elementsToCheck = [
                {name: 'uploadArea', element: uploadArea},
                {name: 'fileInput', element: fileInput},
                {name: 'analyzeBtn', element: analyzeBtn},
                {name: 'resultsSection', element: resultsSection},
                {name: 'loadingDiv', element: loadingDiv},
                {name: 'resultsContent', element: resultsContent},
                {name: 'fileNameDisplay', element: fileNameDisplay},
                {name: 'dataTextArea', element: dataTextArea},
                {name: 'processTextBtn', element: processTextBtn}
            ];
            
            for (const {name, element} of elementsToCheck) {
                console.log(`🔍 Element ${name}:`, element ? '✅ Found' : '❌ Missing');
            }
            
            // Add text area input listener
            if (dataTextArea) {
                dataTextArea.addEventListener('input', function() {
                    const hasText = this.value.trim().length > 0;
                    if (processTextBtn) {
                        processTextBtn.disabled = !hasText;
                    }
                    // Clear previous preview when text changes
                    hideTextPreview();
                    processedData = null;
                    resetAnalysisButton();
                });
            }
            
            // Check if performAnalysis function exists
            console.log('🔍 performAnalysis function:', typeof performAnalysis);
            
            // Initialize event listeners after elements are found
            if (uploadArea && fileInput) {
                initializeEventListeners();
            } else {
                console.error('❌ Critical elements missing - cannot initialize event listeners');
            }
            
            detectDeviceTypeAndApplyStyles();
            // addResponsiveDebugInfo(); // DISABLED - No debug info display
            console.log('🚀 Responsive system initialized');
            
            // Show welcome message with device info - DISABLED
            // setTimeout(() => {
            //     const deviceInfo = detectDeviceTypeAndApplyStyles();
            //     if (typeof showNotification === 'function') {
            //         showNotification(`🎉 Welcome! Optimized for ${deviceInfo.deviceType.replace('-', ' ')} (${deviceInfo.width}px)`, 'success');
            //     }
            // }, 1000);
        });

        // Handle resize and orientation changes
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                detectDeviceTypeAndApplyStyles();
                // console.log('📱 Orientation changed'); // DISABLED
            }, 100);
        });

        // Original variables and code continue here...

        // ฟังก์ชันสำหรับ Input Method Switching และ Text Processing
        let currentInputMethod = 'csv';
        let processedData = null;

        function switchInputMethod(method) {
            console.log(`🔄 Switching input method to: ${method}`);
            
            // Update tab buttons
            document.getElementById('csvTabBtn').classList.toggle('active', method === 'csv');
            document.getElementById('textTabBtn').classList.toggle('active', method === 'text');
            
            // Update tab content
            document.getElementById('csvInputTab').classList.toggle('active', method === 'csv');
            document.getElementById('textInputTab').classList.toggle('active', method === 'text');
            
            currentInputMethod = method;
            
            // Reset any previous data
            processedData = null;
            resetAnalysisButton();
        }

        function clearTextInput() {
            document.getElementById('dataTextArea').value = '';
            hideTextPreview();
            processedData = null;
            resetAnalysisButton();
        }

        function pasteExample() {
            const exampleData = `LOT1 10.2
LOT1 11.5
LOT1 10.8
LOT2 12.1
LOT2 11.8
LOT2 12.3
LOT3 9.8
LOT3 9.5
LOT3 10.1
LOT4 13.2
LOT4 12.9
LOT4 13.5`;
            
            document.getElementById('dataTextArea').value = exampleData;
            processTextData();
        }

        async function processTextDataSilently() {
            const textArea = document.getElementById('dataTextArea');
            const text = textArea.value.trim();
            
            console.log('🔍 processTextDataSilently called');
            console.log('🔍 Text area content:', text.substring(0, 100) + '...');
            
            if (!text) {
                throw new Error('No text data found');
            }
            
            try {
                // Always use space-separated format
                const separator = /\s+/; // Use space/whitespace separator
                
                const lines = text.split('\n').filter(line => line.trim());
                const data = [];
                const groups = {};
                
                console.log(`🔍 Processing ${lines.length} lines`);
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const parts = line.split(separator);
                    if (parts.length !== 2) {
                        throw new Error(`Line ${i + 1}: Expected 2 columns, got ${parts.length}. Line: "${line}"`);
                    }
                    
                    const lotName = parts[0].trim();
                    const value = parseFloat(parts[1].trim());
                    
                    if (!lotName) {
                        throw new Error(`Line ${i + 1}: LOT name cannot be empty`);
                    }
                    
                    if (isNaN(value)) {
                        throw new Error(`Line ${i + 1}: "${parts[1].trim()}" is not a valid number`);
                    }
                    
                    data.push({ LOT: lotName, DATA: value });
                    
                    if (!groups[lotName]) {
                        groups[lotName] = [];
                    }
                    groups[lotName].push(value);
                }
                
                // Validation
                if (data.length === 0) {
                    throw new Error('No valid data found');
                }
                
                const uniqueGroups = Object.keys(groups);
                if (uniqueGroups.length < 2) {
                    throw new Error(`At least 2 groups required, found ${uniqueGroups.length}`);
                }
                
                // Check minimum data per group
                for (const group of uniqueGroups) {
                    if (groups[group].length < 1) {
                        throw new Error(`Group "${group}" has no data`);
                    }
                }
                
                processedData = data;
                console.log(`✅ Silently processed ${data.length} rows with ${uniqueGroups.length} groups`);
                console.log('🔍 processedData set to:', processedData ? 'exists' : 'null');
                
            } catch (error) {
                console.error('❌ Silent text processing error:', error);
                throw error;
            }
        }

        function processTextData() {
            const textArea = document.getElementById('dataTextArea');
            const processBtn = document.getElementById('processTextBtn');
            const text = textArea.value.trim();
            
            if (!text) {
                showNotification('Please enter some data first', 'error');
                return;
            }
            
            // Disable button and show processing state
            processBtn.disabled = true;
            processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            
            try {
                // Always use space-separated format
                const separator = /\s+/; // Use space/whitespace separator
                
                const lines = text.split('\n').filter(line => line.trim());
                const data = [];
                const groups = {};
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const parts = line.split(separator);
                    if (parts.length !== 2) {
                        throw new Error(`Line ${i + 1}: Expected 2 columns, got ${parts.length}. Line: "${line}"`);
                    }
                    
                    const lotName = parts[0].trim();
                    const value = parseFloat(parts[1].trim());
                    
                    if (!lotName) {
                        throw new Error(`Line ${i + 1}: LOT name cannot be empty`);
                    }
                    
                    if (isNaN(value)) {
                        throw new Error(`Line ${i + 1}: "${parts[1].trim()}" is not a valid number`);
                    }
                    
                    data.push({ LOT: lotName, DATA: value });
                    
                    if (!groups[lotName]) {
                        groups[lotName] = [];
                    }
                    groups[lotName].push(value);
                }
                
                // Validation
                if (data.length === 0) {
                    throw new Error('No valid data found');
                }
                
                const uniqueGroups = Object.keys(groups);
                if (uniqueGroups.length < 2) {
                    throw new Error(`At least 2 groups required, found ${uniqueGroups.length}`);
                }
                
                // Check minimum data per group
                for (const group of uniqueGroups) {
                    if (groups[group].length < 1) {
                        throw new Error(`Group "${group}" has no data`);
                    }
                }
                
                processedData = data;
                showTextPreview(data, groups);
                enableAnalysisButton();
                showNotification(`✅ Successfully processed ${data.length} rows with ${uniqueGroups.length} groups`, 'success');
                
                // Update button to show analysis phase
                processBtn.innerHTML = '<i class="fas fa-chart-line"></i> Analyzing...';
                
                // Auto-perform analysis after successful data processing
                console.log('🚀 Auto-starting analysis after data processing...');
                setTimeout(() => {
                    performAnalysis().finally(() => {
                        // Reset button after analysis completes
                        processBtn.disabled = false;
                        processBtn.innerHTML = '<i class="fas fa-play"></i> Process & Analyze Data';
                    });
                }, 500); // Small delay to allow UI updates
                
            } catch (error) {
                console.error('Text processing error:', error);
                showNotification(`❌ Error processing text: ${error.message}`, 'error');
                hideTextPreview();
                processedData = null;
                resetAnalysisButton();
                
                // Reset button on error
                processBtn.disabled = false;
                processBtn.innerHTML = '<i class="fas fa-play"></i> Process & Analyze Data';
            }
        }

        function showTextPreview(data, groups) {
            const preview = document.getElementById('textDataPreview');
            const table = document.getElementById('previewTable');
            const stats = document.getElementById('previewStats');
            
            // Create preview table (first 10 rows)
            const previewData = data.slice(0, 10);
            let tableHTML = `
                <div class="preview-table">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>LOT</th>
                                <th>DATA</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            previewData.forEach(row => {
                tableHTML += `<tr><td>${row.LOT}</td><td>${row.DATA}</td></tr>`;
            });
            
            if (data.length > 10) {
                tableHTML += `<tr><td colspan="2" style="text-align: center; font-style: italic;">... and ${data.length - 10} more rows</td></tr>`;
            }
            
            tableHTML += '</tbody></table></div>';
            table.innerHTML = tableHTML;
            
            // Create stats
            const uniqueGroups = Object.keys(groups);
            let statsHTML = '<div class="preview-stats">';
            
            statsHTML += `
                <div class="stat-item">
                    <div class="stat-label">Total Rows</div>
                    <div class="stat-value">${data.length}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Groups</div>
                    <div class="stat-value">${uniqueGroups.length}</div>
                </div>
            `;
            
            // Group details
            uniqueGroups.forEach(group => {
                const count = groups[group].length;
                const mean = (groups[group].reduce((a, b) => a + b, 0) / count).toFixed(2);
                statsHTML += `
                    <div class="stat-item">
                        <div class="stat-label">${group}</div>
                        <div class="stat-value">${count} values (avg: ${mean})</div>
                    </div>
                `;
            });
            
            statsHTML += '</div>';
            stats.innerHTML = statsHTML;
            
            preview.classList.remove('hidden');
        }

        function hideTextPreview() {
            const preview = document.getElementById('textDataPreview');
            if (preview) {
                preview.classList.add('hidden');
            }
        }

        function enableAnalysisButton() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            if (analyzeBtn) {
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<i class="fas fa-chart-line"></i> Analyze Data';
            }
        }

        function resetAnalysisButton() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            if (analyzeBtn) {
                analyzeBtn.disabled = false; // Enable the button
                analyzeBtn.innerHTML = '<i class="fas fa-rocket"></i> Perform Analysis';
            }
        }

        // Function to initialize event listeners after DOM is ready
        function initializeEventListeners() {
            console.log('🔗 Initializing event listeners...');
            
            if (!uploadArea || !fileInput) {
                console.error('❌ Critical elements not found for event listeners');
                return;
            }

            // Get the choose file button
            const chooseFileBtn = document.getElementById('chooseFileBtn');

            // Drag and drop events for upload area
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            // Click events - separate for upload area and choose file button
            uploadArea.addEventListener('click', (e) => {
                // Only trigger if not clicking on the choose file button
                if (e.target !== chooseFileBtn && !chooseFileBtn.contains(e.target)) {
                    console.log('📍 Upload area clicked (not button)');
                    fileInput.click();
                }
            });

            // Choose file button event
            if (chooseFileBtn) {
                chooseFileBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📍 Choose file button clicked');
                    fileInput.click();
                });
            }

            // File input change event
            fileInput.addEventListener('change', (e) => {
                console.log('📁 File input changed');
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                } else {
                    console.log('⚠️ No files selected');
                }
            });
            
            // Add event listeners for buttons
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🚀 Analyze button clicked');
                    performAnalysis();
                });
            }
            
            console.log('✅ Event listeners initialized successfully');
        }

        function handleFile(file) {
            console.log('📁 handleFile called with:', file?.name);
            console.log('📊 handleFile call stack:', new Error().stack);
            
            // Prevent double calls
            if (handleFile.isProcessing) {
                console.log('⚠️ handleFile already processing, skipping duplicate call');
                return;
            }
            
            handleFile.isProcessing = true;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                showError('Please select a CSV file.');
                if (analyzeBtn) analyzeBtn.disabled = true;
                if (fileNameDisplay) fileNameDisplay.textContent = '';
                csvFile = null;
                csvFileContent = null;
                handleFile.isProcessing = false;
                return;
            }
            csvFile = file;
            if (fileNameDisplay) fileNameDisplay.textContent = `Selected: ${file.name}`;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                csvFileContent = e.target.result;
                if (analyzeBtn) analyzeBtn.disabled = false;
                console.log('✅ CSV file loaded, analyze button enabled');
                handleFile.isProcessing = false;
            };
            reader.onerror = (e) => {
                showError(`Error reading file: ${e.target.error.name}`);
                if (analyzeBtn) analyzeBtn.disabled = true;
                if (fileNameDisplay) fileNameDisplay.textContent = '';
                csvFile = null;
                csvFileContent = null;
                handleFile.isProcessing = false;
            };
            reader.readAsText(file);
        }

        async function performAnalysis() {
            console.log('🚀 performAnalysis called');
            
            // ตรวจสอบ tab ที่กำลัง active อยู่
            const csvTab = document.getElementById('csvInputTab');
            const textTab = document.getElementById('textInputTab');
            const csvTabActive = csvTab && csvTab.classList.contains('active');
            const textTabActive = textTab && textTab.classList.contains('active');
            
            // อัปเดต currentInputMethod ตาม tab ที่ active
            if (csvTabActive) {
                currentInputMethod = 'csv';
            } else if (textTabActive) {
                currentInputMethod = 'text';
            }
            
            console.log('🔍 Current input method:', currentInputMethod);
            console.log('🔍 CSV tab active:', csvTabActive);
            console.log('🔍 Text tab active:', textTabActive);
            console.log('🔍 Current csvFileContent:', csvFileContent ? 'exists' : 'null');
            console.log('🔍 Current processedData:', processedData ? 'exists' : 'null');
            
            let dataToAnalyze = null;
            
            // ถ้าอยู่ใน text tab ให้ลองประมวลผลข้อมูลจาก textarea ก่อน (ไม่ว่าจะมี processedData หรือไม่)
            if (currentInputMethod === 'text') {
                const textArea = document.getElementById('dataTextArea');
                if (textArea && textArea.value.trim()) {
                    console.log('🔄 Auto-processing text data before analysis...');
                    try {
                        // เรียกใช้ processTextData โดยไม่แสดง UI loading
                        await processTextDataSilently();
                        console.log('✅ Text data auto-processed successfully');
                    } catch (error) {
                        console.error('❌ Auto-processing failed:', error);
                        showError(`📝 Error processing your data: ${error.message}\n\nPlease check your data format:\n• Each line: LOT_name numeric_value\n• Use space separation: LOT1 10.2\n• At least 2 groups required`);
                        return;
                    }
                }
            }
            
            // ตรวจสอบข้อมูลตามวิธีป้อนข้อมูล
            if (currentInputMethod === 'csv') {
                if (!csvFileContent) {
                    console.error('❌ No CSV file content available');
                    showError('📁 Please upload a CSV file first.\n\n1. Click "Choose File" or drag & drop your CSV file\n2. Wait for the file to be processed\n3. Then click "Perform Analysis"');
                    return;
                }
                dataToAnalyze = csvFileContent;
            } else if (currentInputMethod === 'text') {
                if (!processedData) {
                    console.error('❌ No processed text data available after auto-processing');
                    showError('📝 Please paste your data in the text area above.\n\nExpected format:\nLOT1 10.2\nLOT1 11.5\nLOT2 12.1\nLOT2 11.8\n\nEach line: LOT_name numeric_value (space-separated)');
                    return;
                }
                dataToAnalyze = processedData;
            } else {
                console.error('❌ Unknown input method:', currentInputMethod);
                showError('❓ Please choose your data input method:\n\n• Upload a CSV file in the CSV Upload tab, OR\n• Use Copy & Paste tab to input your data manually');
                return;
            }

            // Clear previous results and messages
            resultsContent.innerHTML = '';
            clearMessages();
            
            console.log('📱 Setting up UI for loading...');
            
            // Show results section and loading
            resultsSection.style.display = 'block';
            resultsSection.classList.add('visible');
            loadingDiv.style.display = 'flex';
            loadingDiv.classList.remove('hidden');
            resultsContent.style.display = 'none';
            
            // Estimate processing time and start progress bar
            const dataSize = dataToAnalyze.length;
            window.lastAnalyzedDataSize = dataSize; // Store for learning system
            
            if (window.estimateProcessingTime && window.startProgressBar) {
                const estimatedTime = window.estimateProcessingTime(dataSize);
                console.log(`📊 Data size: ${dataSize}, Estimated time: ${estimatedTime}ms`);
                window.startProgressBar();
            } else if (window.startProgressBar) {
                window.startProgressBar();
            }

            const lslInput = document.getElementById('lsl').value;
            const uslInput = document.getElementById('usl').value;
            const lsl = lslInput ? parseFloat(lslInput) : null;
            const usl = uslInput ? parseFloat(uslInput) : null;

            console.log('📊 Input values:', { 
                lsl, 
                usl, 
                dataLength: dataToAnalyze.length,
                inputMethod: currentInputMethod
            });

            if (lslInput && isNaN(lsl)) {
                showError('LSL must be a valid number.');
                hideLoading();
                return;
            }
            if (uslInput && isNaN(usl)) {
                showError('USL must be a valid number.');
                hideLoading();
                return;
            }

            try {
                console.log('🔄 Starting analysis...');
                
                // Convert data to proper format for backend
                let csvDataForBackend;
                if (currentInputMethod === 'text') {
                    // Convert array of objects to CSV string format
                    console.log('🔄 Converting text data to CSV format...');
                    csvDataForBackend = dataToAnalyze.map(row => `${row.LOT},${row.DATA}`).join('\n');
                    console.log('📝 Converted CSV data sample:', csvDataForBackend.substring(0, 100) + '...');
                    
                    // Validate conversion
                    if (!csvDataForBackend || csvDataForBackend.length === 0) {
                        throw new Error('Failed to convert text data to CSV format');
                    }
                } else {
                    // CSV data is already in string format
                    csvDataForBackend = dataToAnalyze;
                }
                
                const requestData = {
                    csv_data: csvDataForBackend,
                    LSL: lsl,
                    USL: usl
                };
                
                console.log('📝 Request data prepared:');
                console.log('   - Input method:', currentInputMethod);
                console.log('   - Data type:', typeof csvDataForBackend);
                console.log('   - Data rows:', csvDataForBackend.split('\n').length);
                console.log('   - Sample data:', csvDataForBackend.substring(0, 200) + '...');
                
                // Use relative URL for production compatibility
                const url = '/analyze_anova';
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log(`✅ Response received:`, response.status);

                console.log('📊 Response status:', response.status);
                console.log('📋 Response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Error response:', errorText);
                    
                    let errorMessage = `Server error: ${response.status}`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText.substring(0, 200) + '...';
                    }
                    
                    throw new Error(errorMessage);
                }

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const responseText = await response.text();
                    console.error('❌ Non-JSON response:', responseText);
                    throw new Error('Server returned non-JSON response. Check server logs.');
                }

                console.log('🎯 Parsing JSON response...');
                const results = await response.json();
                console.log('✅ Successfully received results:', Object.keys(results));
                
                displayResults(results);

            } catch (error) {
                console.error('💥 Analysis error:', error);
                hideLoading();
                showError(`Analysis failed: ${error.message}`);
            }
        }

        function hideLoading() {
            console.log('🔄 Hiding loading UI');
            
            // Stop progress bar animation
            if (window.stopProgressBar) {
                window.stopProgressBar();
            }
            
            loadingDiv.style.display = 'none';
            loadingDiv.classList.add('hidden');
            resultsContent.style.display = 'none';
        }

        function clearMessages() {
            const messageDiv = document.getElementById('messageArea');
            if (messageDiv) {
                messageDiv.remove();
            }
        }

        // Helper function to safely format numbers
        function safeToFixed(value, decimals = 4) {
            if (value == null || isNaN(value)) {
                return 'N/A';
            }
            return Number(value).toFixed(decimals);
        }

        function displayResults(results) {
            console.log('🎯 displayResults called with keys:', Object.keys(results));
            
            const content = document.getElementById('resultsContent');
            content.innerHTML = '';

            // Table names (without suffix functionality)
            const tableNames = {
                onewayAnalysis: 'Oneway Analysis of Data By LOT',
                anova: 'Analysis of Variance',
                means: 'Means for Oneway ANOVA',
                stdDeviations: 'Means and Std Deviations',
                confidenceQuantile: 'Confidence Quantile',
                hsdMatrix: 'HSD Threshold Matrix',
                connectingLetters: 'Connecting Letters Report',
                orderedDifferences: 'Ordered Differences Report',
                varianceTests: 'Tests that the Variances are Equal',
                welchTest: 'Welch\'s Test',
                tukeyHsd: 'TUKEY-KRAMER HSD POST-HOC ANALYSIS',
                varianceChart: 'Variance Chart',
                meanAbsoluteDeviations: 'MEAN ABSOLUTE DEVIATIONS'
            };
            
            console.log('🏷️ Table names:', tableNames);

            try {
                // 1. Basic Information
                console.log('📊 Creating basic info card...');
                const basicCard = createCard('Basic Information', `
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Information</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Total Data Points</td>
                                    <td>${results.basicInfo?.totalPoints || 'N/A'}</td>
                                </tr>
                                <tr>
                                    <td>Number of LOTs</td>
                                    <td>${results.basicInfo?.numLots || 'N/A'}</td>
                                </tr>
                                <tr>
                                    <td>LOTs Present</td>
                                    <td>${results.basicInfo?.lotNames?.join(', ') || 'N/A'}</td>
                                </tr>
                                ${results.basicInfo?.groupCounts ? Object.keys(results.basicInfo.groupCounts).map(lot => `
                                <tr>
                                    <td>${lot}</td>
                                    <td>${results.basicInfo.groupCounts[lot]} data points</td>
                                </tr>
                                `).join('') : ''}
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Dashboard & Export Buttons -->
                    <div class="dashboard-action dashboard-action-layout">
                        <button class="btn btn-accent btn-min-width-180" onclick="openDashboard()" id="dashboardBtn">
                            Dashboard
                        </button>
                        <button class="btn btn-export btn-min-width-120" onclick="exportDashboard()" id="exportBtn">
                            Export Data
                        </button>
                    </div>
                `, 'result-card result-card-basic');
                content.appendChild(basicCard);
                
                // Debug: Check if buttons are created
                console.log('🔍 Dashboard button found:', document.getElementById('dashboardBtn'));
                console.log('🔍 Export button found:', document.getElementById('exportBtn'));

                // Store results for dashboard
                sessionStorage.setItem('anovaResults', JSON.stringify(results));

                // 1. Combined ANOVA Analysis Group (like Tukey results)
                console.log('📊 Creating combined ANOVA Analysis Group...');
                const anovaAnalysisCard = createCard(
                    ``, 
                    createAnovaAnalysisGroup(results, tableNames),
                    'result-card result-card-anova'
                );
                content.appendChild(anovaAnalysisCard);

                // Create interactive charts after DOM is updated
                if (window.createInteractiveOnewayChart && results.groupData) {
                    setTimeout(() => {
                        console.log('🎨 Creating interactive oneway charts...');
                        window.createInteractiveOnewayChart(results);
                    }, 500);
                }

                // 2. Tukey HSD Results (moved to be right after ANOVA Analysis Group)
                if (results.tukey) {
                    console.log('🔍 Creating Tukey results...');
                    const tukeyCard = createCard(`${tableNames.tukeyHsd}`, 
                        createTukeyResults(results, tableNames),
                        'result-card result-card-tukey');
                    content.appendChild(tukeyCard);
                } else {
                    const noTukeyCard = createCard(`${tableNames.tukeyHsd}`, `
                        <div class="pre-formatted">
                            Tukey-Kramer HSD post-hoc analysis could not be performed due to insufficient data or missing statistical libraries.
                            Requirements: At least 2 groups with sufficient degrees of freedom.
                        </div>
                    `, 'result-card result-card-tukey');
                    content.appendChild(noTukeyCard);
                }

                // 3. Combined Variance Analysis Group (like ANOVA and Tukey results)
                console.log('📈 Creating combined Variance Analysis Group...');
                const varianceAnalysisCard = createCard(
                    `Tests that the Variances are Equal`, 
                    createVarianceAnalysisGroup(results, tableNames),
                    'result-card result-card-variance'
                );
                content.appendChild(varianceAnalysisCard);

                // All variance-related analyses now combined in Variance Analysis Group

                // Oneway Analysis chart moved above means table
                if (false) { // Chart moved above
                    console.log('� Displaying Oneway Analysis chart...');
                    const onewayCard = createCard(`<i class="fas fa-chart-line"></i> ${tableNames.onewayAnalysis}`, `
                            <div class="chart-container" style="position: relative;">
                                <img src="data:image/png;base64,${results.plots.dotplot}" 
                                     alt="Oneway Analysis of Data by LOT" 
                                     data-chart-type="oneway"
                                     id="onewayChart"
                                     style="width: 100%; max-width: 100%;"
                                     title="Oneway Analysis Chart">
                                

                                <div style="text-align: center; margin-top: 12px; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); border: 1px solid var(--border-color);">

                                    <br>
                                    <small style="display: block; color: var(--text-secondary); margin-top: 8px;">
                                        Try: 1) Double-click the chart above, 2) Use Debug Chart button, 3) Use Force Add Listener
                                    </small>
                                </div>
                            </div>
                        `);
                        content.appendChild(onewayCard);
                        
                        // Add event listeners with multiple retry attempts
                        console.log('🔄 Attempting to add double-click listeners...');
                        
                        // Function to add listeners with retry
                        function addChartListeners(retryCount = 0) {
                            const maxRetries = 5;
                            const chartImg = document.getElementById('onewayChart');
                            
                            if (chartImg) {
                                console.log(`✅ Chart found on attempt ${retryCount + 1}`);
                            } else if (retryCount < maxRetries) {
                                console.log(`⏳ Chart not found, retrying... (${retryCount + 1}/${maxRetries})`);
                                setTimeout(() => addChartListeners(retryCount + 1), 1000);
                            } else {
                                console.log('❌ Failed to find chart after', maxRetries, 'attempts');
                            }
                        }
                        

                        
                        // Start adding listeners
                        setTimeout(() => addChartListeners(), 100);
                } else {
                    console.log('❌ No dotplot data found in results');
                }


                if (results.basicInfo && results.basicInfo.rawGroups) {
                    const flatData = [];
                    Object.keys(results.basicInfo.rawGroups).forEach(lot => {
                        results.basicInfo.rawGroups[lot].forEach(value => {
                            flatData.push({ LOT: lot, DATA: value });
                        });
                    });
                    

                } else {
                    console.log('❌ No raw data found in results');
                }



                // Show results
                // Stop progress bar animation
                if (window.stopProgressBar) {
                    window.stopProgressBar();
                }
                
                loadingDiv.style.display = 'none';
                loadingDiv.classList.add('hidden');
                resultsContent.style.display = 'block';
                console.log('✅ All results displayed successfully');
                
                // Auto-scroll to Basic Information section after analysis completion
                setTimeout(() => {
                    // First try to find the Basic Information card specifically
                    const basicInfoCard = Array.from(document.querySelectorAll('.result-card h3')).find(h3 => 
                        h3.textContent.includes('Basic Information')
                    )?.parentElement;
                    
                    if (basicInfoCard) {
                        console.log('🎯 Auto-scrolling to Basic Information card...');
                        // Scroll with better positioning and faster animation
                        const yOffset = -80; // Offset to show some space above the card
                        const y = basicInfoCard.getBoundingClientRect().top + window.pageYOffset + yOffset;
                        
                        // Use faster scrolling with custom CSS animation
                        document.documentElement.style.scrollBehavior = 'auto';
                        
                        // Smooth but faster scroll using requestAnimationFrame
                        const startY = window.pageYOffset;
                        const targetY = y;
                        const distance = targetY - startY;
                        const duration = 300; // Reduced from smooth default (~1000ms) to 300ms
                        let startTime = null;
                        
                        function animateScroll(currentTime) {
                            if (startTime === null) startTime = currentTime;
                            const timeElapsed = currentTime - startTime;
                            const progress = Math.min(timeElapsed / duration, 1);
                            
                            // Easing function for smooth acceleration/deceleration
                            const easeInOutCubic = progress < 0.5 ? 4 * progress * progress * progress : (progress - 1) * (2 * progress - 2) * (2 * progress - 2) + 1;
                            
                            window.scrollTo(0, startY + (distance * easeInOutCubic));
                            
                            if (timeElapsed < duration) {
                                requestAnimationFrame(animateScroll);
                            } else {
                                document.documentElement.style.scrollBehavior = 'smooth'; // Restore default
                            }
                        }
                        
                        requestAnimationFrame(animateScroll);
                        
                        // Add a subtle highlight effect to draw attention (faster)
                        basicInfoCard.style.transform = 'scale(1.02)';
                        basicInfoCard.style.transition = 'transform 0.2s ease';
                        setTimeout(() => {
                            basicInfoCard.style.transform = 'scale(1)';
                        }, 300);
                        
                    } else {
                        // Fallback: scroll to results content area with faster animation
                        const resultsSection = document.querySelector('.results-content');
                        if (resultsSection) {
                            console.log('🎯 Auto-scrolling to results section...');
                            resultsSection.scrollIntoView({
                                behavior: 'auto', // Use instant scroll as fallback
                                block: 'start',
                                inline: 'nearest'
                            });
                        } else {
                            console.log('⚠️ Results section not found for auto-scroll');
                        }
                    }
                }, 300); // Reduced from 800ms to 300ms for faster response
                
            } catch (error) {
                console.error('❌ Error in displayResults:', error);
                showError(`Error displaying results: ${error.message}`);
                hideLoading();
            }
        }

        // ฟังก์ชัน Export ข้อมูล analysis - Enhanced version with PowerPoint support
        function exportDashboard() {
            console.log('🎯 exportDashboard() called'); // Debug log
            
            try {
                // Create export options modal
            const modal = document.createElement('div');
            modal.className = 'export-modal';
            modal.innerHTML = `
                <div class="export-modal-content">
                    <div class="export-modal-header">
                        <h3><i class="fas fa-download"></i> Export Analysis Results</h3>
                        <button class="export-modal-close" onclick="closeExportModal()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="export-modal-body">
                        <div class="export-options">
                            <button class="export-option pdf-option" onclick="exportPDF()">
                                <div class="export-icon">
                                    <i class="fas fa-file-pdf"></i>
                                </div>
                                <div class="export-content">
                                    <span class="export-title">PDF Report</span>
                                    <small class="export-desc">Professional analysis report</small>
                                    <div class="export-features">
                                        <span>• Comprehensive analysis</span>
                                        <span>• Charts & tables</span>
                                        <span>• Publication ready</span>
                                    </div>
                                </div>
                            </button>
                            <button class="export-option ppt-option" onclick="exportPowerPoint()">
                                <div class="export-icon">
                                    <i class="fas fa-file-powerpoint"></i>
                                </div>
                                <div class="export-content">
                                    <span class="export-title">PowerPoint</span>
                                    <small class="export-desc">Presentation slides</small>
                                    <div class="export-features">
                                        <span>• Ready to present</span>
                                        <span>• Visual charts</span>
                                        <span>• Professional slides</span>
                                    </div>
                                </div>
                            </button>
                            <!-- ANOVA Card Image option removed -->
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add CSS if not exists
            if (!document.querySelector('#exportModalCSS')) {
                const style = document.createElement('style');
                style.id = 'exportModalCSS';
                style.textContent = `
                    .export-modal {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        -webkit-backdrop-filter: blur(8px);
                        backdrop-filter: blur(8px);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    
                    .export-modal-content {
                        background: var(--bg-primary);
                        border-radius: 20px;
                        padding: 0;
                        max-width: 700px;
                        width: 95%;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                        border: 1px solid var(--border-color);
                        animation: slideInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    
                    .export-modal-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 2rem 2rem 1rem 2rem;
                        border-bottom: 1px solid var(--border-color);
                        background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
                        border-radius: 20px 20px 0 0;
                    }
                    
                    .export-modal-header h3 {
                        margin: 0;
                        color: var(--text-primary);
                        font-size: 1.5rem;
                        font-weight: 700;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                    }
                    
                    .export-modal-header h3 i {
                        color: var(--accent-color);
                        font-size: 1.3rem;
                    }
                    
                    .export-modal-close {
                        background: rgba(255, 255, 255, 0.1);
                        border: none;
                        font-size: 1.2rem;
                        color: var(--text-secondary);
                        cursor: pointer;
                        padding: 10px;
                        border-radius: 50%;
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        width: 40px;
                        height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    
                    .export-modal-close:hover {
                        background: rgba(239, 68, 68, 0.1);
                        color: #ef4444;
                        transform: rotate(90deg) scale(1.1);
                    }
                    
                    .export-modal-body {
                        padding: 2rem;
                    }
                    
                    .export-description {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 1rem;
                        background: rgba(59, 130, 246, 0.1);
                        border: 1px solid rgba(59, 130, 246, 0.2);
                        border-radius: 12px;
                        margin-bottom: 2rem;
                    }
                    
                    .export-description i {
                        color: var(--accent-color);
                        font-size: 1.2rem;
                    }
                    
                    .export-description p {
                        margin: 0;
                        color: var(--text-secondary);
                        font-size: 0.95rem;
                        line-height: 1.5;
                    }
                    
                    .export-options {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                        gap: 1.5rem;
                    }
                    
                    .export-option {
                        display: flex;
                        align-items: flex-start;
                        gap: 1rem;
                        padding: 1.5rem;
                        border: 2px solid var(--border-color);
                        border-radius: 16px;
                        background: var(--bg-secondary);
                        cursor: pointer;
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .export-option::before {
                        content: '';
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, transparent 0%, rgba(59, 130, 246, 0.1) 100%);
                        opacity: 0;
                        transition: opacity 0.3s ease;
                    }
                    
                    .export-option:hover::before {
                        opacity: 1;
                    }
                    
                    .export-option:hover {
                        border-color: var(--accent-color);
                        transform: translateY(-4px) scale(1.02);
                        box-shadow: 0 20px 40px -12px rgba(59, 130, 246, 0.3);
                    }
                    
                    .export-icon {
                        flex-shrink: 0;
                        width: 60px;
                        height: 60px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 12px;
                        transition: all 0.3s ease;
                    }
                    
                    .pdf-option .export-icon {
                        background: rgba(239, 68, 68, 0.1);
                        color: #ef4444;
                    }
                    
                    .excel-option .export-icon {
                        background: rgba(34, 197, 94, 0.1);
                        color: #22c55e;
                    }
                    
                    .ppt-option .export-icon {
                        background: rgba(249, 115, 22, 0.1);
                        color: #f97316;
                    }
                    
                    .img-option .export-icon {
                        background: rgba(139, 92, 246, 0.1);
                        color: #8b5cf6;
                    }
                    
                    .json-option .export-icon {
                        background: rgba(45, 55, 72, 0.1);
                        color: #2D3748;
                    }
                    
                    .export-icon i {
                        font-size: 1.8rem;
                    }
                    
                    .export-content {
                        flex: 1;
                        text-align: left;
                    }
                    
                    .export-title {
                        display: block;
                        font-weight: 700;
                        font-size: 1.1rem;
                        color: var(--text-primary);
                        margin-bottom: 0.5rem;
                    }
                    
                    .export-desc {
                        display: block;
                        font-size: 0.9rem;
                        color: var(--text-secondary);
                        margin-bottom: 1rem;
                    }
                    
                    .export-features {
                        display: flex;
                        flex-direction: column;
                        gap: 0.25rem;
                    }
                    
                    .export-features span {
                        font-size: 0.8rem;
                        color: var(--text-secondary);
                        opacity: 0.8;
                    }
                    
                    @keyframes fadeIn {
                        from { 
                            opacity: 0; 
                        }
                        to { 
                            opacity: 1; 
                        }
                    }
                    
                    @keyframes slideInUp {
                        from { 
                            transform: translateY(60px) scale(0.95); 
                            opacity: 0; 
                        }
                        to { 
                            transform: translateY(0) scale(1); 
                            opacity: 1; 
                        }
                    }
                    
                    /* Responsive design */
                    @media (max-width: 768px) {
                        .export-modal-content {
                            width: 100%;
                            height: 100%;
                            max-height: 100vh;
                            border-radius: 0;
                            margin: 0;
                        }
                        
                        .export-modal-header {
                            border-radius: 0;
                        }
                        
                        .export-options {
                            grid-template-columns: 1fr;
                        }
                        
                        .export-option {
                            padding: 1rem;
                        }
                        
                        .export-icon {
                            width: 50px;
                            height: 50px;
                        }
                        
                        .export-icon i {
                            font-size: 1.5rem;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            } catch (error) {
                console.error('❌ Error in exportDashboard:', error);
            }
        }
        
        function closeExportModal() {
            const modal = document.querySelector('.export-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        function exportPDF() {
            closeExportModal();
            
            // Show loading indicator
            const exportBtn = document.querySelector('.btn-export') || document.getElementById('exportBtn');
            if (!exportBtn) {
                showNotification('Export button not found! Please refresh the page.', 'error');
                return;
            }
            
            const originalText = exportBtn.innerHTML;
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating PDF...';
            exportBtn.disabled = true;

            // Get stored analysis results
            const storedResults = sessionStorage.getItem('anovaResults');
            
            if (!storedResults) {
                showNotification('No analysis data available to export! Please run an analysis first.', 'error');
                exportBtn.innerHTML = originalText;
                exportBtn.disabled = false;
                return;
            }

            try {
                const fullResults = JSON.parse(storedResults);
                
                // Check if we have required data
                if (!fullResults.anova || !fullResults.basicInfo) {
                    showNotification('Incomplete analysis data. Please run the analysis again.', 'error');
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    return;
                }

                // ✅ ตรวจสอบความครบถ้วนของข้อมูลก่อน export
                const requiredSections = {
                    'Analysis of Variance': fullResults.anova,
                    'Means for Oneway Anova': fullResults.means?.groupStatsPooledSE,
                    'Means and Std Deviations': fullResults.means?.groupStatsIndividual,
                    'Confidence Quantile': fullResults.tukey?.qCrit,
                    'HSD Threshold Matrix': fullResults.tukey?.hsdMatrix,
                    'Connecting Letters Report': fullResults.tukey?.connectingLettersTable,
                    'Ordered Differences Report': fullResults.tukey?.comparisons,
                    'Tests that Variances are Equal': fullResults.levene || fullResults.bartlett,
                    'Welch\'s Test': fullResults.welch
                };
                
                const missingSections = [];
                for (const [section, data] of Object.entries(requiredSections)) {
                    if (!data) {
                        missingSections.push(section);
                    }
                }
                
                if (missingSections.length > 0) {
                    showNotification(`⚠️ Some sections are missing: ${missingSections.slice(0,2).join(', ')}${missingSections.length > 2 ? ' and others' : ''}. Export will continue with available data.`, 'warning');
                }

                // ✅ Capture chart images for PDF export
                const pdfChartImages = {};
                try {
                    // Capture Oneway Analysis Chart
                    const onewayCanvas = document.getElementById('onewayAnalysisChart');
                    if (onewayCanvas) {
                        // Create a white background for the chart
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = onewayCanvas.width;
                        tempCanvas.height = onewayCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        
                        // Fill white background
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw original chart on top
                        ctx.drawImage(onewayCanvas, 0, 0);
                        
                        pdfChartImages.onewayChart = tempCanvas.toDataURL('image/png');
                        console.log('✅ Captured onewayAnalysisChart for PDF with white background');
                    } else {
                        console.warn('⚠️ onewayAnalysisChart canvas not found for PDF');
                    }
                } catch (e) {
                    console.error('❌ Error capturing charts for PDF:', e);
                }

                // ✅ ส่งข้อมูลครบถ้วนไปยัง backend สำหรับ PDF generation
                fetch('/export_pdf', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        result: fullResults,
                        webChartImages: pdfChartImages,  // ✅ ส่งรูปภาพ chart ด้วย
                        completeness: {
                            total: Object.keys(requiredSections).length,
                            available: Object.keys(requiredSections).length - missingSections.length,
                            missing: missingSections,
                            sections: requiredSections
                        }
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Create and download PDF file
                        const byteCharacters = atob(data.pdf_data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const pdfBlob = new Blob([byteArray], {type: 'application/pdf'});
                        
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(pdfBlob);
                        link.download = data.filename || `anova-analysis-${new Date().toISOString().split('T')[0]}.pdf`;
                        link.click();
                        
                        showNotification('PDF report generated and downloaded successfully!', 'success');
                    } else {
                        showNotification('Error generating PDF: ' + (data.error || 'Unknown error'), 'error');
                    }
                })
                .catch(error => {
                    console.error('Error generating PDF:', error);
                    showNotification('Error generating PDF! Please try again.', 'error');
                })
                .finally(() => {
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                });
                
            } catch (error) {
                console.error('Error processing export data:', error);
                showNotification('Error processing export data!', 'error');
                exportBtn.innerHTML = originalText;
                exportBtn.disabled = false;
            }
        }
        
        // ฟังก์ชัน Capture Card เป็นรูปภาพ
        async function captureCardAsImage(cardSelector, options = {}) {
            const card = document.querySelector(cardSelector);
            if (!card) {
                console.warn(`⚠️ Card not found: ${cardSelector}`);
                return null;
            }

            try {
                const canvas = await html2canvas(card, {
                    backgroundColor: '#ffffff',
                    scale: options.scale || 2,
                    useCORS: true,
                    allowTaint: true,
                    logging: false,
                    onclone: function(clonedDoc) {
                        // ซ่อน zoom controls
                        const zoomControls = clonedDoc.querySelectorAll('.chart-zoom-controls');
                        zoomControls.forEach(ctrl => ctrl.style.display = 'none');
                        
                        // ซ่อนปุ่ม export ถ้ามี
                        const exportBtns = clonedDoc.querySelectorAll('.export-card-container, .btn-export-card');
                        exportBtns.forEach(btn => btn.style.display = 'none');
                    }
                });
                
                return canvas.toDataURL('image/png', 1.0);
            } catch (error) {
                console.error(`❌ Error capturing card ${cardSelector}:`, error);
                return null;
            }
        }

        async function exportPowerPoint() {
            closeExportModal();
            
            const storedResults = sessionStorage.getItem('anovaResults');
            const csvData = sessionStorage.getItem('lastCsvData');
            
            if (!storedResults) {
                showNotification('No analysis data available for export!', 'error');
                return;
            }
            
            try {
                const fullResults = JSON.parse(storedResults);
                
                // Show loading indicator
                const exportBtn = document.querySelector('.btn-export') || document.getElementById('exportBtn');
                let originalText = '<i class="fas fa-file-powerpoint"></i> Export to PowerPoint';
                if (exportBtn) {
                    originalText = exportBtn.innerHTML;
                    exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating PowerPoint...';
                    exportBtn.disabled = true;
                    console.log('🔄 Export button state changed to loading...');
                }
                
                // แสดง notification ว่ากำลังสร้างรูปภาพ
                showNotification('กำลังสร้างรูปภาพจาก Cards...', 'info');
                
                // ✅ Capture Card Images using html2canvas
                const cardImages = {};
                
                console.log('📸 Capturing ANOVA Card...');
                cardImages.anovaCard = await captureCardAsImage('.result-card-anova');
                if (cardImages.anovaCard) console.log('✅ ANOVA Card captured');
                
                console.log('📸 Capturing Tukey Card...');
                cardImages.tukeyCard = await captureCardAsImage('.result-card-tukey');
                if (cardImages.tukeyCard) console.log('✅ Tukey Card captured');
                
                console.log('📸 Capturing Variance Card...');
                cardImages.varianceCard = await captureCardAsImage('.result-card-variance');
                if (cardImages.varianceCard) console.log('✅ Variance Card captured');
                
                // ✅ Also capture chart canvases (fallback)
                const chartImages = {};
                try {
                    const onewayCanvas = document.getElementById('onewayAnalysisChart');
                    if (onewayCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = onewayCanvas.width;
                        tempCanvas.height = onewayCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(onewayCanvas, 0, 0);
                        chartImages.onewayChart = tempCanvas.toDataURL('image/png');
                    }
                    
                    const tukeyCanvas = document.getElementById('tukeyChart');
                    if (tukeyCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = tukeyCanvas.width;
                        tempCanvas.height = tukeyCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(tukeyCanvas, 0, 0);
                        chartImages.tukeyChart = tempCanvas.toDataURL('image/png');
                    }
                    
                    const varianceCanvas = document.getElementById('varianceChart');
                    if (varianceCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = varianceCanvas.width;
                        tempCanvas.height = varianceCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(varianceCanvas, 0, 0);
                        chartImages.varianceChart = tempCanvas.toDataURL('image/png');
                    }
                } catch (e) {
                    console.error('❌ Error capturing charts:', e);
                }

                // ✅ รับค่า slide title จาก textbox
                const slideTitleInput = document.getElementById('slideTitleInput');
                const customSlideTitle = slideTitleInput ? slideTitleInput.value.trim() : '';
                const finalSlideTitle = customSlideTitle || 'Statistic comparison result';
                
                console.log(`📝 PowerPoint Slide Title: "${finalSlideTitle}"`);

                // ✅ เตรียมข้อมูลครบถ้วนทั้งหมดสำหรับ PowerPoint
                const completeExportData = {
                    // ✅ ส่งรูปภาพ Card (ใหม่!)
                    cardImages: cardImages,
                    
                    // ✅ ส่งรูปภาพกราฟ (fallback)
                    chartImages: chartImages,
                    
                    // ✅ ส่งผลการวิเคราะห์ทั้งหมด
                    analysisResults: fullResults,
                    
                    // ✅ ส่งข้อมูลดิบสำหรับสร้าง DataFrame ใหม่
                    rawData: {
                        csvData: csvData || '',
                        method: currentInputMethod || 'csv',
                        processedData: processedData || null
                    },
                    
                    // ✅ ส่งข้อมูลแต่ละกลุ่มแยกชัดเจน
                    groupsData: fullResults.basicInfo?.rawGroups || {},
                    
                    // ✅ ส่ง custom slide title
                    customSlideTitle: finalSlideTitle,
                    
                    // ✅ ส่ง metadata เพิ่มเติม
                    exportMetadata: {
                        exportTime: new Date().toISOString(),
                        inputMethod: currentInputMethod,
                        hasSpecLimits: !!(fullResults.specLimits?.lsl || fullResults.specLimits?.usl),
                        totalDataPoints: fullResults.basicInfo?.totalPoints,
                        groupCount: fullResults.basicInfo?.numLots,
                        analysisVersion: '2.0',
                        useCardImages: true  // Flag บอกว่าใช้รูป card
                    },
                    
                    // ✅ ส่งการตั้งค่าเพิ่มเติม
                    settings: {
                        lsl: document.getElementById('lsl')?.value || null,
                        usl: document.getElementById('usl')?.value || null
                    }
                };
                
                console.log('📤 Sending complete export data with card images:', completeExportData);
                
                // ✅ Add timeout safety net (60 seconds - เพิ่มเวลาเพราะต้อง capture รูป)
                const timeoutId = setTimeout(() => {
                    console.warn('⏱️ Export timeout - resetting button');
                    const timeoutBtn = document.querySelector('.btn-export') || document.getElementById('exportBtn');
                    if (timeoutBtn) {
                        timeoutBtn.innerHTML = originalText;
                        timeoutBtn.disabled = false;
                    }
                    showNotification('Export is taking longer than expected. Please try again.', 'warning');
                }, 60000);
                
                fetch('/export_powerpoint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(completeExportData)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => Promise.reject(err));
                    }
                    return response.blob();
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    const now = new Date();
                    const timestamp = now.getFullYear().toString() + 
                                    (now.getMonth() + 1).toString().padStart(2, '0') + 
                                    now.getDate().toString().padStart(2, '0') + '_' +
                                    now.getHours().toString().padStart(2, '0') + 
                                    now.getMinutes().toString().padStart(2, '0') + 
                                    now.getSeconds().toString().padStart(2, '0');
                    a.download = `Statistics_Analysis_report_${timestamp}.pptx`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    
                    showNotification('PowerPoint presentation downloaded successfully!', 'success');
                })
                .catch(error => {
                    console.error('PowerPoint export error:', error);
                    showNotification(error.error || 'Failed to export PowerPoint presentation', 'error');
                })
                .finally(() => {
                    clearTimeout(timeoutId);
                    console.log('🔄 Resetting export button state...');
                    const currentExportBtn = document.querySelector('.btn-export') || document.getElementById('exportBtn');
                    if (currentExportBtn) {
                        currentExportBtn.innerHTML = originalText;
                        currentExportBtn.disabled = false;
                        console.log('✅ Export button reset successfully');
                    }
                });
                
            } catch (error) {
                console.error('Error preparing export data:', error);
                showNotification('Error preparing data for export!', 'error');
                
                const errorExportBtn = document.querySelector('.btn-export') || document.getElementById('exportBtn');
                if (errorExportBtn) {
                    errorExportBtn.innerHTML = '<i class="fas fa-file-powerpoint"></i> Export to PowerPoint';
                    errorExportBtn.disabled = false;
                }
            }
        }



        // Notification system - Same as dashboard.html
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <i class="fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i>
                ${message}
            `;
            
            // Add styles
            notification.style.cssText = `
                position: fixed;
                top: 90px;
                right: 30px;
                background: ${type === 'success' ? 'var(--success-color)' : type === 'error' ? 'var(--error-color)' : 'var(--primary-color)'};
                color: white;
                padding: 15px 20px;
                border-radius: var(--radius);
                box-shadow: var(--shadow-lg);
                z-index: 1001;
                display: flex;
                align-items: center;
                gap: 10px;
                animation: slideInRight 0.3s ease;
                max-width: 300px;
                font-family: 'Times New Roman', Times, serif;
                font-size: 0.9rem;
                font-weight: 500;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Add CSS animations for notifications - Ensure this runs immediately
        (function() {
            if (!document.getElementById('notificationStyles')) {
                const style = document.createElement('style');
                style.id = 'notificationStyles';
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes slideOutRight {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        })();

        // Test function for notification system (for debugging)
        function testNotification() {
            console.log('Testing notification...');
            showNotification('Test notification working!', 'success');
        }

        // Make testNotification available globally for console testing
        window.testNotification = testNotification;

        // Function to preview export data (for debugging)
        function previewExportData() {
            const storedResults = sessionStorage.getItem('anovaResults');
            if (!storedResults) {
                console.log('No analysis data found');
                return;
            }

            const fullResults = JSON.parse(storedResults);
            const filteredResults = {
                ...(fullResults.means && { means: fullResults.means }),
                ...(fullResults.anova && { anova: fullResults.anova }),
                ...(fullResults.levene && { levene: fullResults.levene }),
                ...(fullResults.brownForsythe && { brownForsythe: fullResults.brownForsythe }),
                ...(fullResults.bartlett && { bartlett: fullResults.bartlett }),
                ...(fullResults.madStats && { madStats: fullResults.madStats }),
                ...(fullResults.tukey && { tukey: fullResults.tukey }),
                ...(fullResults.plots && { plots: fullResults.plots })
            };

            console.log('🔍 Export Preview:');
            console.log('📊 Full data keys:', Object.keys(fullResults));
            console.log('📋 Filtered data keys (will be exported):', Object.keys(filteredResults));
            console.log('❌ Excluded: basicInfo');
            return filteredResults;
        }

        // Make previewExportData available globally for console testing
        window.previewExportData = previewExportData;

        function createCard(title, contentHtml, customClass = 'result-card') {
            const card = document.createElement('div');
            card.className = customClass;
            card.innerHTML = `
                <h3>${title}</h3>
                ${contentHtml}
            `;
            return card;
        }

        function createANOVATable(anova) {
            // Function to get color based on p-value significance
            function getPValueColor(pValue) {
                if (pValue < 0.05) {
                    return 'style="color: #F44336; font-weight: bold;"'; // Red for significant
                } else {
                    return 'style="color: #4CAF50; font-weight: bold;"'; // Green for not significant
                }
            }
            
            return `
                <div class="table-container">
                    <table class="anova-table">
                        <thead>
                            <tr>
                                <th>Source</th>
                                <th>DF</th>
                                <th>Sum of Squares</th>
                                <th>Mean Square</th>
                                <th>F Ratio</th>
                                <th>Prob > F</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Lot</td>
                                <td>${anova.dfBetween}</td>
                                <td>${anova.ssBetween.toFixed(8)}</td>
                                <td>${anova.msBetween.toExponential(6)}</td>
                                <td>${anova.fStatistic.toFixed(4)}</td>
                                <td ${getPValueColor(anova.pValue)}>${anova.pValue.toFixed(4)}</td>
                            </tr>
                            <tr>
                                <td>Error</td>
                                <td>${anova.dfWithin}</td>
                                <td>${anova.ssWithin.toFixed(8)}</td>
                                <td>${anova.msWithin.toExponential(6)}</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>C Total</td>
                                <td>${anova.dfTotal}</td>
                                <td>${anova.ssTotal.toFixed(8)}</td>
                                <td></td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            `;
        }

        function createWelchTable(welch) {
            // Function to get color based on p-value significance
            function getPValueColor(pValue) {
                if (pValue < 0.05) {
                    return 'style="color: #F44336; font-weight: bold;"'; // Red for significant
                } else {
                    return 'style="color: #4CAF50; font-weight: bold;"'; // Green for not significant
                }
            }
            
            return `
                <div class="table-container">
                    <table class="anova-table">
                        <thead>
                            <tr>
                                <th>F Ratio</th>
                                <th>DFNum</th>
                                <th>DFDen</th>
                                <th>Prob > F</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>${welch.fStatistic.toFixed(4)}</td>
                                <td>${Math.round(welch.dfNum)}</td>
                                <td>${welch.dfDen.toFixed(3)}</td>
                                <td ${getPValueColor(welch.pValue)}>${welch.pValue.toFixed(4)}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            `;
        }

        function createVarianceAnalysisGroup(results, tableNames = {}) {
            let content = '';
            
            // 1. Interactive Variance Chart
            if (results.plots?.varianceChartData) {
                content += `
                    <div class="chart-container" style="margin-bottom: 20px; position: relative; height: 400px;">
                        <canvas id="varianceChart" style="width: 100%; height: 100%;"></canvas>
                    </div>
                `;
            }
            
            // 2. Mean Absolute Deviations
            if (results.madStats) {
                content += `
                    <div style="margin-bottom: 20px;">
                        ${createMADTable(results.madStats)}
                    </div>
                `;
            }
            
            // 3. Tests that the Variances are Equal
            if (results.levene || results.brownForsythe || results.bartlett) {
                // Function to get color based on p-value significance
                function getPValueColor(pValue) {
                    if (pValue < 0.05) {
                        return 'style="color: #F44336; font-weight: bold;"'; // Red for significant
                    } else {
                        return 'style="color: #4CAF50; font-weight: bold;"'; // Green for not significant
                    }
                }
                
                content += `
                    <div class="table-container" style="margin-bottom: 20px;">
                        <table>
                            <thead>
                                <tr><th>Test</th><th>F Ratio / Stat</th><th>DFNum</th><th>DFDen</th><th>Prob > F</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>O'Brien[.5]</td>
                                    <td>${safeToFixed(results.obrien?.fStatistic, 4)}</td>
                                    <td>${results.obrien?.dfNum !== null && !isNaN(results.obrien?.dfNum) ? results.obrien.dfNum : 'N/A'}</td>
                                    <td>${results.obrien?.dfDen !== null && !isNaN(results.obrien?.dfDen) ? results.obrien.dfDen : 'N/A'}</td>
                                    <td ${results.obrien?.pValue ? getPValueColor(results.obrien.pValue) : ''}>${safeToFixed(results.obrien?.pValue, 4)}</td>
                                </tr>
                                <tr>
                                    <td>Brown-Forsythe</td>
                                    <td>${results.brownForsythe?.fStatistic !== null && !isNaN(results.brownForsythe?.fStatistic) ? results.brownForsythe.fStatistic.toFixed(4) : 'N/A'}</td>
                                    <td>${results.brownForsythe?.dfNum !== null && !isNaN(results.brownForsythe?.dfNum) ? results.brownForsythe.dfNum : 'N/A'}</td>
                                    <td>${results.brownForsythe?.dfDen !== null && !isNaN(results.brownForsythe?.dfDen) ? results.brownForsythe.dfDen : 'N/A'}</td>
                                    <td ${results.brownForsythe?.pValue ? getPValueColor(results.brownForsythe.pValue) : ''}>${results.brownForsythe?.pValue !== null && !isNaN(results.brownForsythe?.pValue) ? results.brownForsythe.pValue.toFixed(4) : 'N/A'}</td>
                                </tr>
                                <tr>
                                    <td>Levene</td>
                                    <td>${results.levene?.fStatistic !== null && !isNaN(results.levene?.fStatistic) ? results.levene.fStatistic.toFixed(4) : 'N/A'}</td>
                                    <td>${results.levene?.dfNum !== null && !isNaN(results.levene?.dfNum) ? results.levene.dfNum : 'N/A'}</td>
                                    <td>${results.levene?.dfDen !== null && !isNaN(results.levene?.dfDen) ? results.levene.dfDen : 'N/A'}</td>
                                    <td ${results.levene?.pValue ? getPValueColor(results.levene.pValue) : ''}>${results.levene?.pValue !== null && !isNaN(results.levene?.pValue) ? results.levene.pValue.toFixed(4) : 'N/A'}</td>
                                </tr>
                                <tr>
                                    <td>Bartlett</td>
                                    <td>${results.bartlett?.statistic !== null && !isNaN(results.bartlett?.statistic) ? results.bartlett.statistic.toFixed(4) : 'N/A'}</td>
                                    <td>${results.bartlett?.dfNum !== null && !isNaN(results.bartlett?.dfNum) ? results.bartlett.dfNum : 'N/A'}</td>
                                    <td>.</td>
                                    <td ${results.bartlett?.pValue ? getPValueColor(results.bartlett.pValue) : ''}>${results.bartlett?.pValue !== null && !isNaN(results.bartlett?.pValue) ? results.bartlett.pValue.toFixed(4) : 'N/A'}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // 4. Welch's Test
            if (results.welch && results.welch.available && results.welch.fStatistic !== null) {
                content += `
                    <h4>${tableNames.welchTest || "Welch's Test"}</h4>
                    <p style="font-size: 0.85rem; font-weight: 300; color: #666; margin-bottom: 15px; margin-top: 5px;">Welch Anova testing Means Equal, allowing Std Devs Not Equal</p>
                    <div style="margin-bottom: 20px;">
                        ${createWelchTable(results.welch)}
                    </div>
                `;
            }
            
            return content;
        }

        function createAnovaAnalysisGroup(results, tableNames = {}) {
            let content = '';
            
            // 1. Interactive Oneway Analysis Plot
            if (results.plots?.onewayAnalysisPlot) {
                content += `
                    <h4>Oneway Analysis of Data By LOT</h4>
                    <div class="chart-container" style="margin-bottom: 20px; position: relative; height: 400px;">
                        <canvas id="onewayAnalysisChart" style="width: 100%; height: 100%;"></canvas>
                        <div id="fallbackImage" style="display: none;">
                            <img src="data:image/png;base64,${results.plots.onewayAnalysisPlot}" alt="Oneway Analysis Plot" style="width: 100%; max-width: 100%;">
                        </div>
                        <!-- Zoom Controls -->
                        <div class="chart-zoom-controls" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 2px; z-index: 1000;">
                            <button id="zoomInBtn" class="zoom-btn" onclick="zoomChart('onewayAnalysisChart', 1.5)" title="ขยายกราฟ">
                                +
                            </button>
                            <button id="zoomOutBtn" class="zoom-btn" onclick="zoomChart('onewayAnalysisChart', 0.67)" title="ย่อกราฟ">
                                -
                            </button>
                            <button id="resetZoomBtn" class="zoom-btn" onclick="resetChartZoom('onewayAnalysisChart')" title="รีเซ็ตกราฟ">
                                ⌂
                            </button>
                        </div>
                    </div>
                `;
            }
            
            // 2. Interactive Oneway Analysis Chart (dotplot)
            if (results.plots && results.plots.dotplot) {
                content += `
                    <h4>Oneway Analysis Chart</h4>
                    <div class="chart-container" style="position: relative; margin-bottom: 20px; height: 400px;">
                        <canvas id="onewayDotplotChart" style="width: 100%; height: 100%;"></canvas>
                        <div id="fallbackDotplot" style="display: none;">
                            <img src="data:image/png;base64,${results.plots.dotplot}" 
                                 alt="Oneway Analysis of Data by LOT" 
                                 style="width: 100%; max-width: 100%;"
                                 title="Oneway Analysis Chart">
                        </div>
                    </div>
                `;
            }
            
            // 3. Analysis of Variance Table
            if (results.anova) {
                content += `
                    <h4>Analysis of Variance</h4>
                    ${createANOVATable(results.anova)}
                `;
            }
            
            // 4. Means for Oneway ANOVA
            if (results.means?.groupStatsPooledSE) {
                content += `
                    <h4>Means for Oneway ANOVA</h4>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr><th>Level</th><th>Number</th><th>Mean</th><th>Std Error</th><th>Lower 95%</th><th>Upper 95%</th></tr>
                            </thead>
                            <tbody>
                                ${results.means.groupStatsPooledSE.map(row => `
                                    <tr>
                                        <td>${row.Level}</td>
                                        <td>${row.Number}</td>
                                        <td>${row.Mean != null && !isNaN(row.Mean) ? row.Mean.toFixed(6) : 'N/A'}</td>
                                        <td>${row['Std Error'] != null && !isNaN(row['Std Error']) ? row['Std Error'].toFixed(5) : 'N/A'}</td>
                                        <td>${row['Lower 95%'] != null && !isNaN(row['Lower 95%']) ? row['Lower 95%'].toFixed(5) : 'N/A'}</td>
                                        <td>${row['Upper 95%'] != null && !isNaN(row['Upper 95%']) ? row['Upper 95%'].toFixed(5) : 'N/A'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <p style="font-size: 0.85rem; font-weight: 300; color: #666; margin-bottom: 15px; margin-top: 5px;">Std Error uses a pooled estimate of error variance.</p>
                `;
            }
            
            // 5. Means and Std Deviations
            if (results.means?.groupStatsIndividual) {
                content += `
                    <h4>Means and Std Deviations</h4>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr><th>Level</th><th>Number</th><th>Mean</th><th>Std Dev</th><th>Std Err Mean</th><th>Lower 95%</th><th>Upper 95%</th></tr>
                            </thead>
                            <tbody>
                                ${results.means.groupStatsIndividual.map(row => `
                                    <tr>
                                        <td>${row.Level}</td>
                                        <td>${row.Number}</td>
                                        <td>${row.Mean != null && !isNaN(row.Mean) ? row.Mean.toFixed(7) : 'N/A'}</td>
                                        <td>${row['Std Dev'] !== null && !isNaN(row['Std Dev']) ? row['Std Dev'].toFixed(7) : '       NaN '}</td>
                                        <td>${row['Std Err'] !== null && !isNaN(row['Std Err']) ? row['Std Err'].toFixed(7) : '       NaN '}</td>
                                        <td>${row['Lower 95%'] !== null && !isNaN(row['Lower 95%']) ? row['Lower 95%'].toFixed(7) : '       NaN '}</td>
                                        <td>${row['Upper 95%'] !== null && !isNaN(row['Upper 95%']) ? row['Upper 95%'].toFixed(7) : '       NaN '}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            return content;
        }

        function createTukeyResults(results, tableNames = {}) {
            console.log("🔍 Debug Tukey Results:", results);
            console.log("🔍 Debug HSD Matrix:", results.tukey.hsdMatrix);
            console.log("🔍 Debug Comparisons Data:", results.tukey.comparisons);
            console.log("🔍 Debug Connecting Letters:", results.tukey.connectingLettersTable);
            
            // Function to create interactive Tukey chart (to be placed after tables)
            let tukeyChartContent = '';
            if (results.plots && results.plots.tukeyChartData) {
                console.log("✅ Tukey chart data found, will add interactive chart after tables");
                tukeyChartContent = `
                    <h4>Tukey-Kramer HSD Post-hoc Analysis</h4>
                    <div class="chart-container" style="margin: 20px auto; position: relative; height: 400px; max-width: 90%;">
                        <canvas id="tukeyChart" style="width: 100%; height: 100%;"></canvas>
                        <!-- Zoom Controls -->
                        <div class="chart-zoom-controls" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 2px; z-index: 1000;">
                            <button id="tukeyZoomIn" class="zoom-btn" title="ขยายกราฟ">
                                +
                            </button>
                            <button id="tukeyZoomOut" class="zoom-btn" title="ย่อกราฟ">
                                -
                            </button>
                            <button id="tukeyReset" class="zoom-btn" title="รีเซ็ตกราฟ">
                                ⌂
                            </button>
                        </div>
                    </div>
                `;
            } else {
                console.warn("⚠️ Tukey chart data not found in results.plots");
                console.log("Available plots:", Object.keys(results.plots || {}));
            }
            
            // Function to get color based on p-value significance
            function getPValueColor(pValue) {
                if (pValue < 0.05) {
                    return 'style="color: #F44336; font-weight: bold;"'; // Red for significant
                } else {
                    return 'style="color: #4CAF50; font-weight: bold;"'; // Green for not significant
                }
            }
            
            const alpha = 0.05;
            const connectingLettersData = results.tukey.connectingLettersTable;
            const comparisonsData = results.tukey.comparisons;

            // Debug: ตรวจสอบ Letter data
            console.log("🔍 Debug Connecting Letters Data:", connectingLettersData);
            connectingLettersData.forEach(row => {
                console.log(`Level: ${row.Level}, Letter: ${row.Letter || 'NOT_FOUND'}, Mean: ${row.Mean}`);
            });

            // 2. HSD Threshold Matrix as a proper table
            let hsdThresholdSection = `
                <h4>${tableNames.confidenceQuantile || 'Confidence Quantile'}:</h4>
                <div class="table-container" style="max-width: 300px; display: inline-block;">
                    <table style="width: 100%;">
                        <thead>
                            <tr>
                                <th style="text-align: center; width: 50%;">q*</th>
                                <th style="text-align: center; width: 50%;">Alpha</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="text-align: center;">${results.tukey.qCrit.toFixed(6)}</td>
                                <td style="text-align: center;">${alpha}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <h4>${tableNames.hsdMatrix || 'HSD Threshold Matrix'}:</h4>
                <h5>Abs(Dif)-HSD</h5>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>&nbsp;</th>`;

            // สร้าง HSD Threshold Matrix แบบตาราง
            if (results.tukey.hsdMatrix && Object.keys(results.tukey.hsdMatrix).length > 0) {
                console.log("✅ HSD Matrix data found, creating table...");
                // เรียงลำดับ lots ตาม connectingLettersData (Mean จากมากไปน้อย)
                const lots = connectingLettersData.map(row => row.Level);
                console.log("📊 Lots (sorted by Mean):", lots);
                
                // Header row with lot names
                lots.forEach(lot => {
                    hsdThresholdSection += `<th>${lot}</th>`;
                });
                hsdThresholdSection += `
                            </tr>
                        </thead>
                        <tbody>`;
                
                // Data rows
                lots.forEach(lot1 => {
                    hsdThresholdSection += `
                            <tr>
                                <td>${lot1}</td>`;
                    lots.forEach(lot2 => {
                        const value = results.tukey.hsdMatrix[lot1][lot2];
                        let cellValue = '';
                        
                        console.log(`🔍 Matrix value [${lot1}][${lot2}]:`, value);
                        
                        if (value !== undefined && value !== null && !isNaN(value)) {
                            cellValue = value.toFixed(5);  // 5 decimal places like Connecting Letters Report
                        } else {
                            cellValue = 'N/A';
                        }
                        
                        hsdThresholdSection += `<td>${cellValue}</td>`;
                    });
                    hsdThresholdSection += `</tr>`;
                });
                
                hsdThresholdSection += `
                        </tbody>
                    </table>
                </div>
                <p style="font-size: 0.85rem; font-weight: 300; color: #666; margin-bottom: 15px; margin-top: 5px;">Positive values show pairs of means that are significantly different.</p>`;
            } else {
                console.error("❌ HSD Matrix data not found or empty!");
                console.log("Available tukey keys:", Object.keys(results.tukey || {}));
                hsdThresholdSection += `
                    <table>
                        <thead>
                            <tr><th style="background: var(--error-color); color: white;">Error</th></tr>
                        </thead>
                        <tbody>
                            <tr><td style="color: var(--error-color); text-align: center; padding: 20px;">HSD Matrix data not available</td></tr>
                        </tbody>
                    </table>
                </div>`;
            }

            // 2. Connecting Letters Table
            let connectingLettersTable = `
                <h4>${tableNames.connectingLetters || 'Connecting Letters Report'}:</h4>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Level</th><th></th><th>Mean</th><th>Std Error</th></tr>
                        </thead>
                        <tbody>
            `;

            connectingLettersData.forEach(row => {
                connectingLettersTable += `
                    <tr>
                        <td>${row.Level}</td>
                        <td style="font-weight: bold; color: #2D3748; text-align: center;">${row.Letter || 'A'}</td>
                        <td>${row.Mean.toFixed(5)}</td>
                        <td>${row['Std Error'].toFixed(5)}</td>
                    </tr>
                `;
            });
            connectingLettersTable += `
                        </tbody>
                    </table>
                </div>
                <p style="font-size: 0.85rem; font-weight: 300; color: #666; margin-bottom: 15px; margin-top: 5px;">Levels not connected by same letter are significantly different.</p>
            `;

            // 3. Pairwise Comparisons Table
            let comparisonsTable = `
                <h4>${tableNames.orderedDifferences || 'Ordered Differences Report'} (Pairwise Comparisons):</h4>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>- Level</th>
                                <th>Difference</th>
                                <th>Std Err Dif</th>
                                <th>Lower CL</th>
                                <th>Upper CL</th>
                                <th>p-Value</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Check if comparisonsData exists and has content
            if (comparisonsData && comparisonsData.length > 0) {
                console.log("✅ Comparisons data found:", comparisonsData.length, "comparisons");
                comparisonsData.forEach(comp => {
                const isSignificant = comp.p_adj && comp.p_adj < alpha;
                const rowClass = isSignificant ? 'style="background-color: #fff3cd;"' : '';
                
                comparisonsTable += `
                    <tr ${rowClass}>
                        <td>${comp.lot1}</td>
                        <td>${comp.lot2}</td>
                        <td>${comp.rawDiff.toFixed(7)}</td>
                        <td>${comp.stdErrDiff.toFixed(7)}</td>
                        <td>${(Math.round(comp.lowerCL * 1000000) / 1000000).toFixed(6)}</td>
                        <td>${comp.upperCL.toFixed(7)}</td>
                        <td ${comp.p_adj ? getPValueColor(comp.p_adj) : ''}><strong>${comp.p_adj ? comp.p_adj.toFixed(4) : 'N/A'}</strong></td>
                    </tr>
                `;
                });
            } else {
                console.error("❌ No comparisons data found!");
                comparisonsTable += `
                    <tr>
                        <td colspan="7" style="text-align: center; color: var(--error-color); padding: 20px;">
                            No pairwise comparison data available
                        </td>
                    </tr>
                `;
            }
            
            comparisonsTable += `
                        </tbody>
                    </table>
                </div>
            `;

            return hsdThresholdSection + connectingLettersTable + comparisonsTable + tukeyChartContent;
        }

        function createMADTable(madStats) {
            return `
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Count</th>
                                <th>Std Dev</th>
                                <th>MeanAbsDif to Mean</th>
                                <th>MeanAbsDif to Median</th>
                            </tr>
                        </thead>
                        <tbody>
            ${madStats.map(row => `
                                <tr>
                                    <td>${row.Level}</td>
                                    <td>${row.Count}</td>
                                    <td>${row['Std Dev'] !== null && !isNaN(row['Std Dev']) ? row['Std Dev'].toFixed(7) : '         NaN '}</td>
                                    <td>${row['MeanAbsDif to Mean'].toFixed(7)}</td>
                                    <td>${row['MeanAbsDif to Median'].toFixed(7)}</td>
                                </tr>
            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }


        function showMessage(message, type) {
            let messageDiv = document.getElementById('messageArea');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'messageArea';
                messageDiv.style.marginTop = '10px';
                // Adjust where messageArea is appended for better visibility
                // For example, right after the analyze button
                analyzeBtn.parentNode.insertBefore(messageDiv, analyzeBtn.nextSibling);
            }
            messageDiv.className = type;
            messageDiv.innerHTML = message;
        }

        function showError(message) {
            showMessage(message, 'error');
        }

        function showSuccess(message) {
            showMessage(message, 'success');
        }

        // เพิ่มฟังก์ชันทดสอบการเชื่อมต่อ
        async function testConnection() {
            console.log('🔍 Testing server connection...');
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    console.log('✅ Server connection OK');
                    return true;
                } else {
                    console.log('❌ Server health check failed:', response.status);
                    return false;
                }
            } catch (error) {
                console.log('❌ Cannot connect to server:', error.message);
                return false;
            }
        }


        // ฟังก์ชันโหลดผลลัพธ์ล่าสุดจาก sessionStorage เมื่อเปิดหน้าเว็บ
        function loadLastResults() {
            const lastResults = sessionStorage.getItem('anovaResults');
            if (lastResults) {
                try {
                    const results = JSON.parse(lastResults);
                    // แสดงผลลัพธ์ทันที
                    resultsSection.style.display = 'block';
                    resultsSection.classList.add('visible');
                    // Stop progress bar animation
                    if (window.stopProgressBar) {
                        window.stopProgressBar();
                    }
                    
                    loadingDiv.style.display = 'none';
                    loadingDiv.classList.add('hidden');
                    resultsContent.style.display = 'block';
                    displayResults(results);
                    
                    // Test notification system
                    console.log('Testing notification system...');
                    // showNotification('Previous results loaded!', 'info');
                } catch (e) {
                    console.error('Error loading last results:', e);
                }
            }
        }

        // เรียกทดสอบการเชื่อมต่อและโหลดผลลัพธ์ล่าสุดเมื่อโหลดหน้า
        window.addEventListener('load', async () => {
            console.log('🚀 Page loaded, testing connection...');
            const isConnected = await testConnection();
            if (!isConnected) {
                showError('Cannot connect to Flask server. Please make sure the server is running on port 10000.');
            } else {
                console.log('✅ Ready for analysis');
                loadLastResults();
            }
        });

        // Theme functionality removed - using fixed light theme

        function openDashboard() {
            console.log('🎯 openDashboard() called');
            try {
                // Open the dashboard in a new tab or window
                const dashboardUrl = '/dashboard'; // Update this URL to your actual dashboard URL
                console.log('🚀 Opening dashboard at:', dashboardUrl);
                window.open(dashboardUrl, '_blank');
            } catch (error) {
                console.error('❌ Error opening dashboard:', error);
            }
        }
        
        // Test function for debugging
        function testButtons() {
            console.log('🧪 Testing buttons...');
            const dashBtn = document.getElementById('dashboardBtn');
            const expBtn = document.getElementById('exportBtn');
            console.log('Dashboard button:', dashBtn);
            console.log('Export button:', expBtn);
            
            if (dashBtn) {
                console.log('Dashboard button style:', window.getComputedStyle(dashBtn));
                console.log('Dashboard button onclick:', dashBtn.onclick);
            }
            
            if (expBtn) {
                console.log('Export button style:', window.getComputedStyle(expBtn));
                console.log('Export button onclick:', expBtn.onclick);
            }
        }
        
        // Make test function available globally
        window.testButtons = testButtons;



        

        

        

        

        


        // Load version info when page loads - DISABLED
        // document.addEventListener('DOMContentLoaded', loadVersionInfo);
    </script>





        <!-- Simple Footer -->
        <footer class="simple-footer">
            <div class="footer-container">
            </div>
        </footer>
    </main>

    <script>
        // Sidebar functionality
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');
            const mainContent = document.getElementById('mainContent');
            let sidebarOpen = false;

            function toggleSidebar() {
                sidebarOpen = !sidebarOpen;
                
                if (sidebarOpen) {
                    sidebar.classList.add('open');
                    sidebarOverlay.classList.add('show');
                    
                    // On desktop, shift main content
                    if (window.innerWidth > 768) {
                        mainContent.classList.add('shifted');
                    }
                } else {
                    sidebar.classList.remove('open');
                    sidebarOverlay.classList.remove('show');
                    mainContent.classList.remove('shifted');
                }
            }

            function closeSidebar() {
                if (sidebarOpen) {
                    sidebarOpen = false;
                    sidebar.classList.remove('open');
                    sidebarOverlay.classList.remove('show');
                    mainContent.classList.remove('shifted');
                }
            }

            // Event listeners
            sidebarToggle.addEventListener('click', toggleSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);

            // Close sidebar on escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && sidebarOpen) {
                    closeSidebar();
                }
            });

            // Handle window resize
            window.addEventListener('resize', function() {
                if (window.innerWidth <= 768 && sidebarOpen) {
                    mainContent.classList.remove('shifted');
                } else if (window.innerWidth > 768 && sidebarOpen) {
                    mainContent.classList.add('shifted');
                }
            });

            // Handle menu item clicks
            const menuLinks = document.querySelectorAll('.sidebar-menu-link');
            
            // HOME menu functionality
            document.getElementById('homeMenu').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveMenu(this);
                
                // Scroll to top smoothly
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
                
                // Close sidebar on mobile
                if (window.innerWidth <= 768) {
                    closeSidebar();
                }
                
                console.log('Menu clicked: HOME - Scrolling to top');
            });
            
            // Dashboard menu functionality
            document.getElementById('dashboardMenu').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveMenu(this);
                
                // Check if analysis results exist before navigating to dashboard
                const anovaResults = sessionStorage.getItem('anovaResults');
                
                if (anovaResults) {
                    // Navigate to dashboard page
                    window.location.href = '/dashboard';
                } else {
                    // Show message if no analysis results
                    showError('Please complete an ANOVA analysis first before viewing the dashboard.');
                }
                
                // Close sidebar on mobile
                if (window.innerWidth <= 768) {
                    closeSidebar();
                }
                
                console.log('Menu clicked: Dashboard');
            });
            
            // Export menu functionality
            document.getElementById('exportMenu').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveMenu(this);
                
                // Check if analysis results exist before exporting
                const anovaResults = sessionStorage.getItem('anovaResults');
                
                if (anovaResults) {
                    // Trigger export modal (reuse existing export functionality)
                    showExportModal();
                } else {
                    // Show message if no analysis results
                    showError('Please complete an ANOVA analysis first before exporting results.');
                }
                
                // Close sidebar on mobile
                if (window.innerWidth <= 768) {
                    closeSidebar();
                }
                
                console.log('Menu clicked: Export');
            });
            

            
            // Helper function to set active menu
            function setActiveMenu(activeElement) {
                menuLinks.forEach(link => link.classList.remove('active'));
                activeElement.classList.add('active');
            }
            
            // Show export modal function (reuse existing functionality)
            function showExportModal() {
                // Check if export button exists and trigger its functionality
                const exportBtn = document.getElementById('exportBtn');
                if (exportBtn) {
                    exportBtn.click();
                } else {
                    // Create a simple export options dialog
                    const modal = document.createElement('div');
                    modal.className = 'export-modal';
                    modal.innerHTML = `
                        <div class="export-modal-overlay" onclick="closeExportModal()"></div>
                        <div class="export-modal-content">
                            <div class="export-modal-header">
                                <h3>Export Analysis Results</h3>
                                <button class="export-modal-close" onclick="closeExportModal()">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div class="export-modal-body">
                                <div class="export-options">
                                    <button class="btn btn-export" onclick="exportToPDF()">
                                        <i class="fas fa-file-pdf"></i>
                                        Export to PDF
                                    </button>
                                    <button class="btn btn-export" onclick="exportToPowerPoint()">
                                        <i class="fas fa-file-powerpoint"></i>
                                        Export to PowerPoint
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Add modal styles if not exists
                    if (!document.getElementById('exportModalStyles')) {
                        const style = document.createElement('style');
                        style.id = 'exportModalStyles';
                        style.textContent = `
                            .export-modal {
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                z-index: 2000;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            }
                            .export-modal-overlay {
                                position: absolute;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: rgba(0, 0, 0, 0.5);
                            }
                            .export-modal-content {
                                background: var(--bg-card);
                                border-radius: var(--radius);
                                padding: 24px;
                                max-width: 400px;
                                width: 90%;
                                z-index: 1;
                                box-shadow: var(--shadow-lg);
                            }
                            .export-modal-header {
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                margin-bottom: 20px;
                                padding-bottom: 12px;
                                border-bottom: 1px solid var(--border-color);
                            }
                            .export-modal-close {
                                background: none;
                                border: none;
                                font-size: 1.5rem;
                                cursor: pointer;
                                color: var(--text-secondary);
                            }
                            .export-options {
                                display: flex;
                                flex-direction: column;
                                gap: 15px;
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
            }
            
            // Close export modal function
            function closeExportModal() {
                const modal = document.querySelector('.export-modal');
                if (modal) {
                    modal.remove();
                }
            }
            
            // Export functions (reuse existing ones if available)
            function exportToPDF() {
                closeExportModal();
                const anovaResults = JSON.parse(sessionStorage.getItem('anovaResults'));
                
                // ✅ Capture chart images for PDF export
                const pdfChartImages = {};
                try {
                    // Capture Oneway Analysis Chart
                    const onewayCanvas = document.getElementById('onewayAnalysisChart');
                    if (onewayCanvas) {
                        // Create a white background for the chart
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = onewayCanvas.width;
                        tempCanvas.height = onewayCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        
                        // Fill white background
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw original chart on top
                        ctx.drawImage(onewayCanvas, 0, 0);
                        
                        pdfChartImages.onewayChart = tempCanvas.toDataURL('image/png');
                        console.log('✅ Captured onewayAnalysisChart for PDF (modal) with white background');
                    } else {
                        console.warn('⚠️ onewayAnalysisChart canvas not found for PDF (modal)');
                    }
                    
                    // Capture Tukey Chart
                    const tukeyCanvas = document.getElementById('tukeyChart');
                    if (tukeyCanvas) {
                        // Create a white background for the tukey chart
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = tukeyCanvas.width;
                        tempCanvas.height = tukeyCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        
                        // Fill white background
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw original chart on top
                        ctx.drawImage(tukeyCanvas, 0, 0);
                        
                        pdfChartImages.tukeyChart = tempCanvas.toDataURL('image/png');
                        console.log('✅ Captured tukeyChart for PDF (modal) with white background');
                    } else {
                        console.warn('⚠️ tukeyChart canvas not found for PDF (modal)');
                    }
                    
                    // Capture Variance Chart
                    console.log('🔍 DEBUG: Looking for varianceChart canvas...');
                    const varianceCanvas = document.getElementById('varianceChart');
                    console.log('🔍 DEBUG: varianceCanvas element:', varianceCanvas);
                    console.log('🔍 DEBUG: varianceCanvas style:', varianceCanvas?.style?.display);
                    console.log('🔍 DEBUG: varianceCanvas parent visibility:', varianceCanvas?.parentElement?.style?.display);
                    if (varianceCanvas) {
                        console.log('🔍 DEBUG: varianceCanvas dimensions:', varianceCanvas.width, 'x', varianceCanvas.height);
                        console.log('🔍 DEBUG: varianceCanvas clientWidth/Height:', varianceCanvas.clientWidth, 'x', varianceCanvas.clientHeight);
                        
                        // Check if canvas has any content
                        const checkCtx = varianceCanvas.getContext('2d');
                        const imageData = checkCtx.getImageData(0, 0, varianceCanvas.width, varianceCanvas.height);
                        const hasContent = imageData.data.some(pixel => pixel !== 0);
                        console.log('🔍 DEBUG: varianceCanvas has content:', hasContent);
                        // Create a white background for the variance chart
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = varianceCanvas.width;
                        tempCanvas.height = varianceCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        
                        // Fill white background
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw original chart on top
                        ctx.drawImage(varianceCanvas, 0, 0);
                        
                        pdfChartImages.varianceChart = tempCanvas.toDataURL('image/png');
                        console.log('✅ Captured varianceChart for PDF (modal) with white background, size:', pdfChartImages.varianceChart.length);
                    } else {
                        console.warn('⚠️ varianceChart canvas not found for PDF (modal)');
                        console.log('🔍 DEBUG: Available canvas elements:', Array.from(document.querySelectorAll('canvas')).map(c => c.id));
                    }
                } catch (e) {
                    console.error('❌ Error capturing charts for PDF (modal):', e);
                }
                
                fetch('/export_pdf', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        result: anovaResults,
                        webChartImages: pdfChartImages,  // ✅ ส่งรูปภาพ chart ด้วย
                        rawData: anovaResults.basicInfo?.rawGroups || {}
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const link = document.createElement('a');
                        link.href = data.file_url;
                        link.download = data.filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        showSuccess('PDF exported successfully!');
                    } else {
                        showError('Failed to export PDF: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Export error:', error);
                    showError('Error exporting PDF. Please try again.');
                });
            }
            
            function exportToPowerPoint() {
                closeExportModal();
                const anovaResults = JSON.parse(sessionStorage.getItem('anovaResults'));
                
                // ✅ Capture chart images
                const chartImages = {};
                try {
                    // Capture Oneway Analysis Chart
                    const onewayCanvas = document.getElementById('onewayAnalysisChart');
                    if (onewayCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = onewayCanvas.width;
                        tempCanvas.height = onewayCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(onewayCanvas, 0, 0);
                        chartImages.onewayChart = tempCanvas.toDataURL('image/png');
                    }
                    
                    // Capture Tukey Chart
                    const tukeyCanvas = document.getElementById('tukeyChart');
                    if (tukeyCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = tukeyCanvas.width;
                        tempCanvas.height = tukeyCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(tukeyCanvas, 0, 0);
                        chartImages.tukeyChart = tempCanvas.toDataURL('image/png');
                    }
                    
                    // Capture Variance Chart
                    const varianceCanvas = document.getElementById('varianceChart');
                    if (varianceCanvas) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = varianceCanvas.width;
                        tempCanvas.height = varianceCanvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        ctx.drawImage(varianceCanvas, 0, 0);
                        chartImages.varianceChart = tempCanvas.toDataURL('image/png');
                    }
                } catch (e) {
                    console.error('Error capturing charts:', e);
                }
                
                fetch('/export_powerpoint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        analysisResults: anovaResults,
                        groupsData: anovaResults.basicInfo?.rawGroups || {},
                        chartImages: chartImages
                    })
                })
                .then(response => response.blob())
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'Statistics_Analysis_report.pptx';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                    showSuccess('PowerPoint exported successfully!');
                })
                .catch(error => {
                    console.error('Export error:', error);
                    showError('Error exporting PowerPoint. Please try again.');
                });
            }



            // Chart Zoom Functions
            window.chartInstances = {};

            // Register Chart.js zoom plugin
            if (typeof Chart !== 'undefined' && typeof zoomPlugin !== 'undefined') {
                Chart.register(zoomPlugin);
            }

            // Debug function to check chart instances
            window.debugChartInstances = function() {
                console.log('Available chart instances:', Object.keys(window.chartInstances));
                return window.chartInstances;
            };

            // Auto-fit chart to show spec limits function
            window.autoFitChartToSpecLimits = function(chartId) {
                console.log('🎯 Auto-fitting chart to show spec limits');
                const chart = window.chartInstances && window.chartInstances[chartId];
                if (!chart) {
                    console.error(`Chart ${chartId} not found for auto-fit`);
                    return;
                }
                
                // Get spec limit values
                const lslInput = document.getElementById('lsl').value;
                const uslInput = document.getElementById('usl').value;
                const lsl = lslInput ? parseFloat(lslInput) : null;
                const usl = uslInput ? parseFloat(uslInput) : null;
                
                if (lsl === null && usl === null) {
                    console.log('🔍 No spec limits to fit to');
                    return;
                }
                
                console.log(`🎯 Auto-fitting ${chartId} to show spec limits: LSL=${lsl}, USL=${usl}`);
                
                // Call the chart's updateSpecLimits function which now includes Y-axis fitting
                if (chart.updateSpecLimits) {
                    chart.updateSpecLimits();
                    chart.update('none');
                    console.log('✅ Chart auto-fitted to spec limits');
                }
            };

            window.zoomChart = function(chartId, scaleFactor) {
                console.log('🔍 Zoom called with:', chartId, scaleFactor);
                console.log('📊 Available chart instances:', Object.keys(window.chartInstances || {}));
                const chart = window.chartInstances && window.chartInstances[chartId];
                console.log('📈 Chart found:', !!chart);
                
                if (!chart) {
                    console.error('❌ Chart not found:', chartId, 'Available charts:', window.chartInstances);
                    alert('Chart not found! Please check console for details.');
                    return;
                }
                
                console.log('✅ Starting zoom operation...');
                
                try {
                    // ใช้ manual zoom เพื่อให้ควบคุมได้แม่นยำ (Chart.js zoom API มีปัญหา)
                    console.log('Using manual Y-axis zoom');
                    
                    // ตรวจสอบ scales ก่อน
                    if (!chart.scales || !chart.scales.y) {
                        console.error('❌ Y-axis scale not found');
                        alert('Chart scales not available. Please try refreshing the page.');
                        return;
                    }
                    
                    // Manual zoom เฉพาะ Y-axis
                    let currentYMin = chart.scales.y.min;
                    let currentYMax = chart.scales.y.max;
                    
                    console.log('📏 Current Y scale:', {min: currentYMin, max: currentYMax});
                    
                    // หากไม่มีการตั้งค่า min/max ให้ใช้ค่าปัจจุบันจาก scale
                    if (currentYMin === undefined || currentYMax === undefined) {
                        // ลองหาค่าจาก data range
                        const yScale = chart.scales.y;
                        currentYMin = yScale._range?.min ?? yScale.start ?? 0;
                        currentYMax = yScale._range?.max ?? yScale.end ?? 1;
                        
                        // ถ้าไม่มีค่าจาก scale ให้คำนวณจากข้อมูล
                        if (currentYMin === currentYMax || currentYMin === undefined || currentYMax === undefined) {
                            console.log('🔍 Calculating Y-axis range from data...');
                            let dataMin = Infinity;
                            let dataMax = -Infinity;
                            
                            chart.data.datasets.forEach(dataset => {
                                if (dataset.data && Array.isArray(dataset.data)) {
                                    dataset.data.forEach(point => {
                                        if (point && typeof point.y === 'number') {
                                            dataMin = Math.min(dataMin, point.y);
                                            dataMax = Math.max(dataMax, point.y);
                                        }
                                    });
                                }
                            });
                            
                            if (dataMin !== Infinity && dataMax !== -Infinity) {
                                const padding = (dataMax - dataMin) * 0.1; // 10% padding
                                currentYMin = dataMin - padding;
                                currentYMax = dataMax + padding;
                                console.log('📊 Calculated range from data:', currentYMin, 'to', currentYMax);
                            } else {
                                console.error('❌ Cannot determine Y-axis range');
                                alert('Unable to determine chart range. Please try again.');
                                return;
                            }
                        }
                        
                        console.log('Using calculated range:', currentYMin, 'to', currentYMax);
                        
                        if (currentYMin === currentYMax) {
                            console.error('❌ Invalid Y-axis range, cannot zoom');
                            return;
                        }
                    }
                    
                    console.log('Current Y range:', currentYMin, 'to', currentYMax, 'scaleFactor:', scaleFactor);
                    
                    const currentYRange = currentYMax - currentYMin;
                    const centerY = (currentYMin + currentYMax) / 2;
                    
                    // คำนวณ range ใหม่
                    let newYRange;
                    if (scaleFactor > 1) {
                        // Zoom In - ลด range (ย่อ range)
                        newYRange = currentYRange / scaleFactor;
                        console.log('Zoom In: reducing Y range');
                    } else {
                        // Zoom Out - เพิ่ม range (ขยาย range เพื่อแสดงภาพรวมมากขึ้น)
                        newYRange = currentYRange / scaleFactor; // scaleFactor < 1 จะทำให้ newYRange > currentYRange
                        console.log('Zoom Out: increasing Y range');
                    }
                    
                    // ผ่อนปรนการจำกัด zoom เพื่อให้ zoom ได้อย่างอิสระมากขึ้น
                    const originalDataRange = Math.abs(currentYMax - currentYMin);
                    const minYRange = originalDataRange * 0.001; // ขั้นต่ำ 0.1% ของข้อมูลเดิม (zoom in ลึกมาก)
                    const maxYRange = originalDataRange * 100.0; // สูงสุด 10,000% ของข้อมูลเดิม (zoom out กว้างมาก)
                    
                    // ใช้ newYRange โดยตรงหากอยู่ในขอบเขตที่สมเหตุสมผล
                    let finalYRange = newYRange;
                    
                    // จำกัดเฉพาะกรณีที่สุดโต่งเท่านั้น
                    if (newYRange < minYRange) {
                        console.log('⚠️ Zoom in limit reached, using minimum range');
                        finalYRange = minYRange;
                    } else if (newYRange > maxYRange) {
                        console.log('⚠️ Zoom out limit reached, using maximum range');
                        finalYRange = maxYRange;
                    } else {
                        console.log('✅ Zoom range accepted:', finalYRange);
                    }
                    
                    console.log('Final Y range:', finalYRange, 'Center:', centerY);
                    
                    // อัปเดต Y-axis เท่านั้น (X-axis คงที่)
                    const newYMin = centerY - finalYRange / 2;
                    const newYMax = centerY + finalYRange / 2;
                    
                    console.log('Setting Y-axis limits:', newYMin, 'to', newYMax);
                    
                    // ตั้งค่า Y-axis scale ใหม่
                    chart.options.scales.y.min = newYMin;
                    chart.options.scales.y.max = newYMax;
                    
                    // ลบ cache ของ scale เก่าและ force recalculation
                    if (chart.scales && chart.scales.y) {
                        delete chart.scales.y._range;
                        delete chart.scales.y._startValue;
                        delete chart.scales.y._endValue;
                    }
                    
                    console.log('Updating chart...');
                    chart.update('resize'); // ใช้ resize เพื่อ force การคำนวณ scale ใหม่
                    console.log('Chart updated successfully');
                    
                    // Apply dynamic Y-axis precision based on zoom level
                    setTimeout(() => {
                        try {
                            if (chart && chart.options && chart.options.scales && chart.options.scales.y) {
                                chart.options.scales.y.ticks = chart.options.scales.y.ticks || {};
                                
                                // คำนวณความละเอียดตาม zoom level
                                const yRange = finalYRange;
                                let decimalPlaces = 3; // default
                                let maxTicks = 15;
                                
                                if (scaleFactor < 1) {
                                    // Zoom Out - เพิ่มความละเอียดและจำนวน ticks
                                    if (yRange > 1.0) {
                                        decimalPlaces = 2;
                                        maxTicks = 20;
                                    } else if (yRange > 0.1) {
                                        decimalPlaces = 3;
                                        maxTicks = 25;
                                    } else if (yRange > 0.01) {
                                        decimalPlaces = 4;
                                        maxTicks = 30;
                                    } else {
                                        decimalPlaces = 5;
                                        maxTicks = 35;
                                    }
                                } else {
                                    // Zoom In - ความละเอียดปกติ
                                    decimalPlaces = 3;
                                    maxTicks = 15;
                                }
                                
                                chart.options.scales.y.ticks.maxTicksLimit = maxTicks;
                                chart.options.scales.y.ticks.precision = decimalPlaces;
                                chart.options.scales.y.ticks.callback = function(value) {
                                    return value.toFixed(decimalPlaces);
                                };
                                
                                console.log(`Y-axis precision: ${decimalPlaces} decimals, ${maxTicks} ticks, range: ${yRange.toFixed(4)}`);
                            }
                        } catch (precisionError) {
                            console.log('Y-axis precision update failed:', precisionError);
                        }
                    }, 50);
                    
                    // Update spec limit lines to span new chart width (ข้ามการอัปเดตเพื่อไม่ให้รบกวน zoom)
                    if (chart.updateSpecLimits && false) { // ปิดชั่วคราวเพื่อไม่รบกวน zoom
                        setTimeout(() => chart.updateSpecLimits(), 100);
                    }
                    
                } catch (error) {
                    console.error('Zoom function error:', error);
                    // Fallback simple zoom - Y-axis เท่านั้น
                    try {
                        if (chart && chart.scales && chart.scales.y) {
                            const yRange = chart.scales.y.max - chart.scales.y.min;
                            const yCenter = (chart.scales.y.min + chart.scales.y.max) / 2;
                            const newYRange = yRange / scaleFactor;
                            
                            console.log('Fallback zoom - Y range:', yRange, 'New range:', newYRange, 'Factor:', scaleFactor);
                            
                            chart.options.scales.y.min = yCenter - newYRange / 2;
                            chart.options.scales.y.max = yCenter + newYRange / 2;
                            
                            // ลบ cache และ force recalculation
                            if (chart.scales && chart.scales.y) {
                                delete chart.scales.y._range;
                                delete chart.scales.y._startValue;
                                delete chart.scales.y._endValue;
                            }
                            
                            chart.update('resize');
                        }
                    } catch (fallbackError) {
                        console.error('Fallback zoom failed:', fallbackError);
                    }
                }
            };

            window.resetChartZoom = function(chartId) {
                console.log('🔄 Reset zoom called for:', chartId);
                console.log('📊 Available chart instances:', Object.keys(window.chartInstances || {}));
                
                if (!window.chartInstances) {
                    console.error('❌ No chart instances available');
                    alert('Chart instances not available. Please try refreshing the page.');
                    return;
                }
                
                const chart = window.chartInstances[chartId];
                console.log('📈 Chart found for reset:', !!chart);
                
                if (!chart) {
                    console.error('❌ Chart not found for reset:', chartId);
                    alert('Chart not found for reset! Please check console for details.');
                    return;
                }
                
                if (chart) {
                    try {
                        // Reset Y-axis เท่านั้น X-axis ให้คงที่
                        delete chart.options.scales.y.min;
                        delete chart.options.scales.y.max;
                        
                        // รักษา X-axis ให้คงที่ในตำแหน่งเดิม
                        chart.options.scales.x.min = 0.5;
                        chart.options.scales.x.max = chart.data.datasets.filter(d => d.label && d.label.startsWith('LOT')).length + 0.5;
                        
                        // ลบ cache ของ scale และ force recalculation
                        if (chart.scales && chart.scales.y) {
                            delete chart.scales.y._range;
                            delete chart.scales.y._startValue;
                            delete chart.scales.y._endValue;
                            delete chart.scales.y.min;
                            delete chart.scales.y.max;
                        }
                        
                        // Force recalculate Y-axis range based on actual data
                        let yMin = Infinity;
                        let yMax = -Infinity;
                        
                        chart.data.datasets.forEach(dataset => {
                            if (dataset.data && Array.isArray(dataset.data)) {
                                dataset.data.forEach(point => {
                                    if (point && typeof point.y === 'number' && !isNaN(point.y)) {
                                        yMin = Math.min(yMin, point.y);
                                        yMax = Math.max(yMax, point.y);
                                    }
                                });
                            }
                        });
                        
                        // Set proper Y-axis range with padding if data found
                        if (yMin !== Infinity && yMax !== -Infinity) {
                            const yRange = yMax - yMin;
                            const padding = yRange * 0.1; // 10% padding
                            
                            chart.options.scales.y.min = yMin - padding;
                            chart.options.scales.y.max = yMax + padding;
                        }
                        
                        chart.update('resize');
                        
                        // Reset Y-axis precision to default
                        setTimeout(() => {
                            try {
                                if (chart && chart.options && chart.options.scales && chart.options.scales.y) {
                                    chart.options.scales.y.ticks = chart.options.scales.y.ticks || {};
                                    
                                    // รีเซ็ตเป็นค่าเริ่มต้น
                                    chart.options.scales.y.ticks.maxTicksLimit = 15;
                                    chart.options.scales.y.ticks.precision = 4;
                                    chart.options.scales.y.ticks.callback = function(value) {
                                        // Dynamic precision based on value range
                                        const absValue = Math.abs(value);
                                        if (absValue >= 100) {
                                            return value.toFixed(1);
                                        } else if (absValue >= 10) {
                                            return value.toFixed(2);
                                        } else if (absValue >= 1) {
                                            return value.toFixed(3);
                                        } else {
                                            return value.toFixed(4);
                                        }
                                    };
                                    
                                    console.log('Y-axis precision reset to dynamic precision');
                                }
                            } catch (precisionError) {
                                console.log('Y-axis precision reset failed:', precisionError);
                            }
                        }, 50);
                        
                        // Update spec limit lines to span full chart width
                        if (chart.updateSpecLimits) {
                            setTimeout(() => chart.updateSpecLimits(), 100);
                        }
                    } catch (error) {
                        console.log('Chart reset applied:', error);
                    }
                }
            };

            // Interactive Chart Functions
            window.createInteractiveOnewayChart = function(results) {
                console.log('🚀 createInteractiveOnewayChart called');
                
                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    console.warn('⚠️ Chart.js not available, showing fallback images');
                    showFallbackImages();
                    return;
                }
                
                console.log('✅ Chart.js is available, version:', Chart?.version || 'unknown');

                // Create Interactive Oneway Analysis Chart
                if (results.plots?.onewayAnalysisPlot && results.groupData) {
                    setTimeout(() => {
                        createOnewayAnalysisChart(results);
                    }, 100);
                }

                // Create Interactive Dotplot Chart
                if (results.plots?.dotplot && results.groupData) {
                    setTimeout(() => {
                        createOnewayDotplotChart(results);
                    }, 200);
                }

                // Create Interactive Variance Chart
                console.log('🔍 Checking variance chart condition...');
                console.log('📊 results.plots:', results.plots);
                console.log('📊 results.plots?.varianceChartData:', results.plots?.varianceChartData);
                
                if (results.plots?.varianceChartData) {
                    console.log('✅ Creating variance chart...');
                    setTimeout(() => {
                        createVarianceChart(results);
                    }, 300);
                } else {
                    console.log('❌ No variance chart data found');
                }

                // Create Interactive Tukey HSD Chart
                if (results.plots?.tukeyChartData) {
                    setTimeout(() => {
                        createTukeyChart(results);
                    }, 400);
                }
            };

            function showFallbackImages() {
                const analysisCanvas = document.getElementById('onewayAnalysisChart');
                const analysisFallback = document.getElementById('fallbackImage');
                const dotplotCanvas = document.getElementById('onewayDotplotChart');
                const dotplotFallback = document.getElementById('fallbackDotplot');

                if (analysisCanvas && analysisFallback) {
                    analysisCanvas.style.display = 'none';
                    analysisFallback.style.display = 'block';
                }

                if (dotplotCanvas && dotplotFallback) {
                    dotplotCanvas.style.display = 'none';
                    dotplotFallback.style.display = 'block';
                }
            }

            function createOnewayAnalysisChart(results) {
                console.log('🎯 createOnewayAnalysisChart called');
                console.log('📊 Results data:', !!results);
                console.log('📈 Group data:', !!results?.groupData);
                
                const canvas = document.getElementById('onewayAnalysisChart');
                const fallback = document.getElementById('fallbackImage');
                
                console.log('🖼️ Canvas found:', !!canvas);
                console.log('🖼️ Fallback found:', !!fallback);
                
                // Initialize chartInstances if not exists
                if (!window.chartInstances) {
                    console.log('🔧 Initializing chartInstances');
                    window.chartInstances = {};
                }
                
                // Zoom plugin ถูกลงทะเบียนแล้วที่ระดับ global
                
                if (!canvas || !results.groupData) {
                    console.error('❌ Missing canvas or group data');
                    if (fallback) {
                        fallback.style.display = 'block';
                        if (canvas) canvas.style.display = 'none';
                    }
                    return;
                }

                try {
                    const ctx = canvas.getContext('2d');
                
                // Debug logging และตรวจสอบข้อมูลอย่างละเอียด
                console.log('🎯 Chart results:', results);
                console.log('📊 Group means:', results.means?.groupMeans);
                console.log('📈 Sample data values:', Object.values(results.groupData)[0]?.slice(0, 5));
                
                // Prepare data for Chart.js
                const lots = Object.keys(results.groupData).sort();
                const datasets = [];
                
                console.log('🏷️ Processing lots:', lots);

                // Create scatter plot data for each lot with deterministic jitter to maintain consistent positioning
                lots.forEach((lot, index) => {
                    const lotData = results.groupData[lot];
                    console.log(`📊 Processing LOT ${lot} with ${lotData.length} data points`);
                    
                    const scatterData = [];
                    
                    lotData.forEach((value, i) => {
                        // Ensure proper number parsing and validation
                        let numericValue = value;
                        
                        // หากเป็น string ให้แปลงเป็น number
                        if (typeof value === 'string') {
                            numericValue = parseFloat(value);
                        }
                        
                        // ตรวจสอบความถูกต้องของข้อมูล
                        if (typeof numericValue !== 'number' || isNaN(numericValue) || !isFinite(numericValue)) {
                            console.warn(`❌ Invalid data point in LOT ${lot}:`, value, '-> skipping');
                            return;
                        }
                        
                        console.log(`✅ Valid data point: LOT ${lot}[${i}] = ${numericValue.toFixed(6)}`);
                        
                        scatterData.push({
                            x: index + 1 + ((i % 10) - 4.5) * 0.02, // Deterministic jitter based on data index
                            y: numericValue // Ensure Y values are exactly right
                        });
                    });

                    console.log(`📈 LOT ${lot}: Created ${scatterData.length} valid points`);
                    
                    datasets.push({
                        label: `LOT ${lot}`,
                        data: scatterData,
                        backgroundColor: 'rgba(128, 128, 128, 0.6)',
                        borderColor: 'rgba(96, 96, 96, 1)',
                        borderWidth: 1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        showLine: false
                    });
                });

                // Add box plots for each LOT
                lots.forEach((lot, index) => {
                    const lotData = results.groupData[lot];
                    
                    // Calculate box plot statistics
                    const sortedData = lotData.map(v => parseFloat(v)).filter(v => !isNaN(v)).sort((a, b) => a - b);
                    if (sortedData.length === 0) return;

                    const n = sortedData.length;
                    const q1Index = Math.floor(n * 0.25);
                    const q2Index = Math.floor(n * 0.5);
                    const q3Index = Math.floor(n * 0.75);
                    
                    const q1 = sortedData[q1Index];
                    const median = sortedData[q2Index];
                    const q3 = sortedData[q3Index];
                    const iqr = q3 - q1;
                    const min = Math.max(sortedData[0], q1 - 1.5 * iqr);
                    const max = Math.min(sortedData[n - 1], q3 + 1.5 * iqr);

                    const boxWidth = 0.3; // Width of box plot
                    const xPos = index + 1;

                    // Create box plot outline datasets
                    // Box (Q1 to Q3)
                    datasets.push({
                        label: `Box ${lot}`,
                        type: 'line',
                        data: [
                            { x: xPos - boxWidth/2, y: q1 },
                            { x: xPos + boxWidth/2, y: q1 },
                            { x: xPos + boxWidth/2, y: q3 },
                            { x: xPos - boxWidth/2, y: q3 },
                            { x: xPos - boxWidth/2, y: q1 } // Close the box
                        ],
                        borderColor: '#FF0000',
                        borderWidth: 2,
                        backgroundColor: 'transparent',
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 2
                    });

                    // Median line
                    datasets.push({
                        label: `Median ${lot}`,
                        type: 'line',
                        data: [
                            { x: xPos - boxWidth/2, y: median },
                            { x: xPos + boxWidth/2, y: median }
                        ],
                        borderColor: '#FF0000',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 2
                    });

                    // Whiskers
                    // Lower whisker
                    datasets.push({
                        label: `Lower Whisker ${lot}`,
                        type: 'line',
                        data: [
                            { x: xPos, y: q1 },
                            { x: xPos, y: min }
                        ],
                        borderColor: '#FF0000',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 2
                    });

                    // Upper whisker
                    datasets.push({
                        label: `Upper Whisker ${lot}`,
                        type: 'line',
                        data: [
                            { x: xPos, y: q3 },
                            { x: xPos, y: max }
                        ],
                        borderColor: '#FF0000',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 2
                    });

                    // Whisker end caps
                    datasets.push({
                        label: `Whisker Caps ${lot}`,
                        type: 'line',
                        data: [
                            { x: xPos - boxWidth/4, y: min },
                            { x: xPos + boxWidth/4, y: min },
                            { x: NaN, y: NaN }, // Break the line
                            { x: xPos - boxWidth/4, y: max },
                            { x: xPos + boxWidth/4, y: max }
                        ],
                        borderColor: '#FF0000',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 2
                    });
                });

                // Add means line if available
                if (results.means && results.means.groupMeans) {
                    const meanData = lots.map((lot, index) => {
                        const meanValue = results.means.groupMeans[lot];
                        const numericMean = typeof meanValue === 'number' ? meanValue : parseFloat(meanValue);
                        
                        if (isNaN(numericMean)) {
                            console.warn('Invalid mean value detected for lot:', lot, 'value:', meanValue);
                            return null;
                        }
                        
                        return {
                            x: index + 1,
                            y: numericMean
                        };
                    }).filter(point => point !== null); // Remove invalid mean points

                    datasets.push({
                        label: 'Group Means',
                        data: meanData,
                        backgroundColor: '#27ae60',
                        borderColor: '#27ae60',
                        borderWidth: 3,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        pointStyle: 'rect', // Square markers
                        showLine: true,
                        tension: 0,
                        fill: false,
                        type: 'line',
                        order: 0 // Ensure means line appears on top
                    });
                }

                // Store spec limits for dynamic updates
                const specLimits = results.specLimits;
                console.log('📋 Spec Limits received:', specLimits);
                
                if (specLimits) {
                    console.log('📊 LSL:', specLimits.lsl, 'Type:', typeof specLimits.lsl);
                    console.log('📊 USL:', specLimits.usl, 'Type:', typeof specLimits.usl);
                } else {
                    console.log('❌ No spec limits provided');
                }

                // Add LSL (Lower Spec Limit) red line if available
                if (specLimits && specLimits.lsl !== null && specLimits.lsl !== undefined) {
                    const lslValue = typeof specLimits.lsl === 'number' ? specLimits.lsl : parseFloat(specLimits.lsl);
                    
                    if (!isNaN(lslValue)) {
                        console.log(`📊 Adding LSL line at Y = ${lslValue}`);
                        
                        // สร้างข้อมูลเส้น LSL ที่ขยายตลอดความกว้างของแผนภูมิ
                        const lslData = [
                            { x: 0.5, y: lslValue },
                            { x: lots.length + 0.5, y: lslValue }
                        ];
                        
                        datasets.push({
                            label: `LSL = ${lslValue.toFixed(3)}`,
                            data: lslData,
                            backgroundColor: '#F44336',
                            borderColor: '#F44336',
                            borderWidth: 2.5,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: true,
                            tension: 0,
                            fill: false,
                            type: 'line',
                            borderDash: [],
                            order: 1,
                            specType: 'lsl',
                            specValue: lslValue
                        });
                        
                        console.log(`✅ LSL line added successfully`);
                    } else {
                        console.warn(`❌ Invalid LSL value: ${specLimits.lsl}`);
                    }
                } else {
                    console.log(`ℹ️ No LSL specified`);
                }

                // Add USL (Upper Spec Limit) red line if available
                if (specLimits && specLimits.usl !== null && specLimits.usl !== undefined) {
                    const uslValue = typeof specLimits.usl === 'number' ? specLimits.usl : parseFloat(specLimits.usl);
                    
                    if (!isNaN(uslValue)) {
                        console.log(`📊 Adding USL line at Y = ${uslValue}`);
                        
                        // สร้างข้อมูลเส้น USL ที่ขยายตลอดความกว้างของแผนภูมิ
                        const uslData = [
                            { x: 0.5, y: uslValue },
                            { x: lots.length + 0.5, y: uslValue }
                        ];
                        
                        datasets.push({
                            label: `USL = ${uslValue.toFixed(3)}`,
                            data: uslData,
                            backgroundColor: '#F44336',
                            borderColor: '#F44336',
                            borderWidth: 2.5,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: true,
                            tension: 0,
                            fill: false,
                            type: 'line',
                            borderDash: [],
                            order: 1,
                            specType: 'usl',
                            specValue: uslValue
                        });
                        
                        console.log(`✅ USL line added successfully`);
                    } else {
                        console.warn(`❌ Invalid USL value: ${specLimits.usl}`);
                    }
                } else {
                    console.log(`ℹ️ No USL specified`);
                }

                const chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        // บังคับให้ Chart.js คำนวณ scale อย่างแม่นยำ
                        animation: {
                            duration: 0
                        },
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                display: false // ปิดการแสดงผล legend
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const lot = lots[Math.floor(context[0].parsed.x) - 1];
                                        return `LOT ${lot}`;
                                    },
                                    label: function(context) {
                                        // Hide tooltip for Group Means dataset
                                        const datasetLabel = context.dataset.label;
                                        if (datasetLabel === 'Group Means') {
                                            return null; // Don't show tooltip for mean group
                                        }
                                        // แสดงค่า Y จริงที่แม่นยำ
                                        const actualY = context.parsed.y;
                                        return `Value: ${actualY.toFixed(4)}`;
                                    }
                                }
                            },
                            zoom: {
                                limits: {
                                    y: {min: 'original', max: 'original'},
                                    x: {min: 'original', max: 'original'}
                                },
                                pan: {
                                    enabled: true,
                                    mode: 'y'  // Pan เฉพาะแกน Y
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false // ปิด wheel zoom ตามคำขอ
                                    },
                                    pinch: {
                                        enabled: false // ปิด pinch zoom ด้วย
                                    },
                                    mode: 'y'  // Zoom เฉพาะแกน Y (ถ้าเปิดใช้งาน)
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'LOT',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    stepSize: 1,
                                    callback: function(value) {
                                        // Check if this value corresponds to a LOT position
                                        const roundedValue = Math.round(value);
                                        if (roundedValue >= 1 && roundedValue <= lots.length && Math.abs(value - roundedValue) < 0.01) {
                                            return lots[roundedValue - 1] || '';
                                        }
                                        return '';
                                    },
                                    stepSize: null,
                                    maxTicksLimit: lots.length + 2
                                },
                                // Override tick generation to use exact LOT positions
                                afterBuildTicks: function(scale) {
                                    scale.ticks = lots.map((lot, index) => ({
                                        value: index + 1,
                                        label: lot
                                    }));
                                },
                                min: 0.5,
                                max: lots.length + 0.5
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'DATA',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxTicksLimit: 15, // เพิ่มจำนวน ticks ที่แสดง
                                    precision: 3, // แสดงทศนิยม 3 ตำแหน่ง
                                    callback: function(value) {
                                        return value.toFixed(3); // แสดงทศนิยม 3 ตำแหน่ง
                                    }
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'point'
                        }
                    }
                });

                // Function to update spec limit lines to span full chart width
                function updateSpecLimits() {
                    if (!chart) {
                        console.warn('❌ Chart not available for updateSpecLimits');
                        return;
                    }
                    
                    console.log('🔄 Updating spec limit lines...');
                    
                    const xMin = chart.scales.x.min || 0.5;
                    const xMax = chart.scales.x.max || (lots.length + 0.5);
                    
                    console.log(`📊 Chart X range: ${xMin} to ${xMax}`);
                    
                    let specLinesUpdated = 0;
                    
                    chart.data.datasets.forEach((dataset, index) => {
                        if (dataset.specType === 'lsl' || dataset.specType === 'usl') {
                            console.log(`🔧 Updating ${dataset.specType.toUpperCase()} line at Y = ${dataset.specValue}`);
                            
                            dataset.data = [
                                { x: xMin, y: dataset.specValue },
                                { x: xMax, y: dataset.specValue }
                            ];
                            
                            specLinesUpdated++;
                        }
                    });
                    
                    console.log(`✅ Updated ${specLinesUpdated} spec limit lines`);
                    
                    // ตรวจสอบและคำนวณ Y-axis range อย่างแม่นยำจากข้อมูลจริงทั้งหมด
                    let yMin = Infinity;
                    let yMax = -Infinity;
                    let dataPointCount = 0;
                    
                    // คำนวณ range จาก dataset ของจุดข้อมูลจริง (ไม่ใช่ spec limits หรือ mean lines)
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.data && Array.isArray(dataset.data) && 
                            dataset.label && dataset.label.startsWith('LOT ')) {
                            dataset.data.forEach(point => {
                                if (point && typeof point.y === 'number' && !isNaN(point.y) && 
                                    isFinite(point.y)) {
                                    yMin = Math.min(yMin, point.y);
                                    yMax = Math.max(yMax, point.y);
                                    dataPointCount++;
                                }
                            });
                        }
                    });
                    
                    console.log(`📊 Y-axis calculation: Found ${dataPointCount} valid data points`);
                    console.log(`📊 Data range: ${yMin.toFixed(6)} to ${yMax.toFixed(6)}`);
                    
                    // ตั้งค่า Y-axis range ให้ครอบคลุมข้อมูลจริงและ spec limits
                    if (yMin !== Infinity && yMax !== -Infinity && dataPointCount > 0) {
                        let finalYMin = yMin;
                        let finalYMax = yMax;
                        
                        // ตรวจสอบว่ามี spec limits หรือไม่และขยาย range ให้ครอบคลุม
                        const lslInput = document.getElementById('lsl').value;
                        const uslInput = document.getElementById('usl').value;
                        const lsl = lslInput ? parseFloat(lslInput) : null;
                        const usl = uslInput ? parseFloat(uslInput) : null;
                        
                        if (lsl !== null && !isNaN(lsl)) {
                            finalYMin = Math.min(finalYMin, lsl);
                            console.log(`📊 Including LSL ${lsl} in Y-axis range`);
                        }
                        
                        if (usl !== null && !isNaN(usl)) {
                            finalYMax = Math.max(finalYMax, usl);
                            console.log(`📊 Including USL ${usl} in Y-axis range`);
                        }
                        
                        const finalYRange = finalYMax - finalYMin;
                        const padding = Math.max(finalYRange * 0.05, 0.001); // เพิ่ม padding เป็น 5% เพื่อให้เห็นเส้นชัดเจน
                        
                        // ตั้งค่า Y-axis range อย่างชัดเจน
                        chart.options.scales.y.min = finalYMin - padding;
                        chart.options.scales.y.max = finalYMax + padding;
                        
                        console.log(`📊 Setting Y-axis range with spec limits: ${(finalYMin - padding).toFixed(6)} to ${(finalYMax + padding).toFixed(6)}`);
                    }
                    
                    chart.update('none');
                    
                    // Apply Y-axis precision for better display - รันเพียงครั้งเดียว
                    try {
                        if (chart.options && chart.options.scales && chart.options.scales.y && 
                            !chart.options.scales.y.ticks.precisionApplied) {
                            chart.options.scales.y.ticks = chart.options.scales.y.ticks || {};
                            chart.options.scales.y.ticks.maxTicksLimit = 15;
                            chart.options.scales.y.ticks.precision = 4;
                            chart.options.scales.y.ticks.precisionApplied = true; // ป้องกัน recursion
                            chart.options.scales.y.ticks.callback = function(value) {
                                // Dynamic precision based on value range
                                const absValue = Math.abs(value);
                                if (absValue >= 100) {
                                    return value.toFixed(1);
                                } else if (absValue >= 10) {
                                    return value.toFixed(2);
                                } else if (absValue >= 1) {
                                    return value.toFixed(3);
                                } else {
                                    return value.toFixed(4);
                                }
                            };
                        }
                    } catch (precisionError) {
                        console.log('Y-axis precision update in updateSpecLimits failed:', precisionError);
                    }
                }

                // Auto-fit Y-axis to include spec limits เมื่อมีการใส่ LSL/USL
                function autoFitYAxisWithSpecLimits() {
                    const lslInput = document.getElementById('lsl').value;
                    const uslInput = document.getElementById('usl').value;
                    const lsl = lslInput ? parseFloat(lslInput) : null;
                    const usl = uslInput ? parseFloat(uslInput) : null;
                    
                    if (lsl !== null || usl !== null) {
                        console.log('🎯 Auto-fitting Y-axis to include spec limits: LSL=' + lsl + ', USL=' + usl);
                        
                        // เรียก updateSpecLimits ที่มีการปรับ Y-axis ให้ครอบคลุม spec limits
                        updateSpecLimits();
                        
                        // บังคับให้ chart อัพเดท
                        setTimeout(() => {
                            chart.update('none');
                            console.log('✅ Chart auto-fitted to show spec limits within frame');
                        }, 50);
                    } else {
                        console.log('🔍 No spec limits detected, skipping auto-fit');
                    }
                }

                // Initial update of spec limits - รันทันทีและหลังจาก chart render
                console.log('🚀 Triggering initial spec limits update');
                setTimeout(() => {
                    autoFitYAxisWithSpecLimits();
                }, 100);
                
                // รันอีกครั้งหลังจาก chart เสร็จสิ้นการ render
                setTimeout(() => {
                    console.log('🔄 Second spec limits update for safety');
                    autoFitYAxisWithSpecLimits();
                }, 300);
                
                // Auto-fit หลังจาก chart render เสร็จสมบูรณ์
                setTimeout(() => {
                    console.log('🎯 Final auto-fit to ensure spec limits are visible');
                    autoFitYAxisWithSpecLimits();
                }, 1000);
                
                // Enhance Y-axis precision for better zoom experience
                chart.options.scales.y.ticks.maxTicksLimit = 20;
                chart.options.scales.y.ticks.precision = 4;
                chart.options.scales.y.ticks.callback = function(value) {
                    // Dynamic precision based on value range
                    const absValue = Math.abs(value);
                    if (absValue >= 10) {
                        return value.toFixed(2);
                    } else if (absValue >= 1) {
                        return value.toFixed(3);
                    } else if (absValue >= 0.1) {
                        return value.toFixed(4);
                    } else {
                        return value.toFixed(5);
                    }
                };
                
                // Store chart instance and update function for zoom controls
                console.log('💾 Storing chart instance as onewayAnalysisChart');
                window.chartInstances['onewayAnalysisChart'] = chart;
                chart.updateSpecLimits = updateSpecLimits;
                console.log('✅ Chart stored successfully, available instances:', Object.keys(window.chartInstances));
                
                // ทดสอบปุ่ม zoom หลังจากสร้าง chart
                setTimeout(() => {
                    console.log('🧪 Testing zoom buttons...');
                    const zoomInBtn = document.getElementById('zoomInBtn');
                    const zoomOutBtn = document.getElementById('zoomOutBtn');
                    const resetBtn = document.getElementById('resetZoomBtn');
                    
                    console.log('🔍 Zoom In button found:', !!zoomInBtn);
                    console.log('🔍 Zoom Out button found:', !!zoomOutBtn);
                    console.log('🏠 Reset button found:', !!resetBtn);
                    
                    if (zoomInBtn) {
                        console.log('✅ Zoom buttons are ready');
                        
                        // ทดสอบ zoom function
                        if (typeof window.zoomChart === 'function') {
                            console.log('✅ zoomChart function is available');
                        } else {
                            console.error('❌ zoomChart function not available!');
                        }
                        
                        if (typeof window.resetChartZoom === 'function') {
                            console.log('✅ resetChartZoom function is available');
                        } else {
                            console.error('❌ resetChartZoom function not available!');
                        }
                    } else {
                        console.error('❌ Zoom buttons not found!');
                    }
                }, 500);

                } catch (error) {
                    console.error('Error creating interactive oneway analysis chart:', error);
                    if (fallback) {
                        fallback.style.display = 'block';
                        canvas.style.display = 'none';
                    }
                }
            }

            function createOnewayDotplotChart(results) {
                const canvas = document.getElementById('onewayDotplotChart');
                const fallback = document.getElementById('fallbackDotplot');
                
                if (!canvas || !results.groupData) {
                    if (fallback) {
                        fallback.style.display = 'block';
                        canvas.style.display = 'none';
                    }
                    return;
                }

                try {
                    const ctx = canvas.getContext('2d');
                
                // Prepare data for dotplot
                const lots = Object.keys(results.groupData).sort();
                const datasets = [];

                // Create dot plot data for each lot
                lots.forEach((lot, lotIndex) => {
                    const lotData = results.groupData[lot];
                    
                    // Count frequency of each value for stacking
                    const valueCount = {};
                    lotData.forEach(value => {
                        const numericValue = typeof value === 'number' ? value : parseFloat(value);
                        if (!isNaN(numericValue)) {
                            const roundedValue = Math.round(numericValue * 1000) / 1000;
                            valueCount[roundedValue] = (valueCount[roundedValue] || 0) + 1;
                        }
                    });

                    const scatterData = [];
                    Object.keys(valueCount).forEach(value => {
                        const count = valueCount[value];
                        const numericValue = parseFloat(value);
                        
                        if (!isNaN(numericValue)) {
                            for (let i = 0; i < count; i++) {
                                scatterData.push({
                                    x: lotIndex + 1 + (i - (count - 1) / 2) * 0.1,
                                    y: numericValue
                                });
                            }
                        }
                    });

                    datasets.push({
                        label: `LOT ${lot}`,
                        data: scatterData,
                        backgroundColor: 'rgba(128, 128, 128, 0.6)',
                        borderColor: 'rgba(96, 96, 96, 1)',
                        borderWidth: 1,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        showLine: false
                    });
                });

                // Add means line if available
                if (results.means && results.means.groupMeans) {
                    const meanData = lots.map((lot, index) => {
                        const meanValue = results.means.groupMeans[lot];
                        const numericMean = typeof meanValue === 'number' ? meanValue : parseFloat(meanValue);
                        
                        if (isNaN(numericMean)) {
                            console.warn('Invalid mean value detected for lot:', lot, 'value:', meanValue);
                            return null;
                        }
                        
                        return {
                            x: index + 1,
                            y: numericMean
                        };
                    }).filter(point => point !== null); // Remove invalid mean points

                    datasets.push({
                        label: 'Group Means',
                        data: meanData,
                        backgroundColor: '#27ae60',
                        borderColor: '#27ae60',
                        borderWidth: 3,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        pointStyle: 'rect', // Square markers
                        showLine: true,
                        tension: 0,
                        fill: false,
                        type: 'line',
                        order: 0 // Ensure means line appears on top
                    });
                }

                // Add LSL (Lower Spec Limit) red line if available
                console.log('🔍 Checking LSL in chart:', {
                    hasSpecLimits: !!results.specLimits,
                    specLimits: results.specLimits,
                    lsl: results.specLimits ? results.specLimits.lsl : 'no spec limits'
                });
                
                if (results.specLimits && results.specLimits.lsl !== null && results.specLimits.lsl !== undefined) {
                    const lslValue = typeof results.specLimits.lsl === 'number' ? results.specLimits.lsl : parseFloat(results.specLimits.lsl);
                    console.log('📊 LSL value to add to chart:', lslValue);
                    
                    if (!isNaN(lslValue)) {
                        const lslData = [
                            { x: 0.5, y: lslValue },
                            { x: lots.length + 0.5, y: lslValue }
                        ];
                        console.log('✅ Adding LSL line to chart with data:', lslData);

                        datasets.push({
                            label: `LSL = ${lslValue.toFixed(3)}`,
                            data: lslData,
                            backgroundColor: '#F44336',
                            borderColor: '#F44336',
                            borderWidth: 2.5,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: true,
                            tension: 0,
                            fill: false,
                            type: 'line',
                            borderDash: [],
                            order: 1
                        });
                    }
                }

                // Add USL (Upper Spec Limit) red line if available
                console.log('🔍 Checking USL in chart:', {
                    hasSpecLimits: !!results.specLimits,
                    usl: results.specLimits ? results.specLimits.usl : 'no spec limits'
                });
                
                if (results.specLimits && results.specLimits.usl !== null && results.specLimits.usl !== undefined) {
                    const uslValue = typeof results.specLimits.usl === 'number' ? results.specLimits.usl : parseFloat(results.specLimits.usl);
                    console.log('📊 USL value to add to chart:', uslValue);
                    
                    if (!isNaN(uslValue)) {
                        const uslData = [
                            { x: 0.5, y: uslValue },
                            { x: lots.length + 0.5, y: uslValue }
                        ];
                        console.log('✅ Adding USL line to chart with data:', uslData);

                        datasets.push({
                            label: `USL = ${uslValue.toFixed(3)}`,
                            data: uslData,
                            backgroundColor: '#F44336',
                            borderColor: '#F44336',
                            borderWidth: 2.5,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: true,
                            tension: 0,
                            fill: false,
                            type: 'line',
                            borderDash: [],
                            order: 1
                        });
                    }
                }

                new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Oneway Analysis Chart (Dotplot)',
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const lot = lots[Math.floor(context[0].parsed.x) - 1];
                                        return `LOT ${lot}`;
                                    },
                                    label: function(context) {
                                        return `Value: ${context.parsed.y.toFixed(3)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'LOT',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    stepSize: 1,
                                    callback: function(value) {
                                        // Show only at integer positions to center LOT numbers
                                        const intValue = Math.round(value);
                                        if (intValue < 1 || intValue > lots.length) return '';
                                        return lots[intValue - 1] || '';
                                        
                                    }
                                },
                                min: 0.5,
                                max: lots.length + 0.5
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'DATA',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxTicksLimit: 15, // เพิ่มจำนวน ticks ที่แสดง
                                    precision: 3, // แสดงทศนิยม 3 ตำแหน่ง
                                    callback: function(value) {
                                        return value.toFixed(3); // แสดงทศนิยม 3 ตำแหน่ง
                                    }
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'point'
                        }
                    }
                });
                } catch (error) {
                    console.error('Error creating interactive oneway dotplot chart:', error);
                    if (fallback) {
                        fallback.style.display = 'block';
                        canvas.style.display = 'none';
                    }
                }
            }

            function createVarianceChart(results) {
                console.log('🎯 createVarianceChart called');
                console.log('📊 Variance chart data:', results.plots?.varianceChartData);
                
                const canvas = document.getElementById('varianceChart');
                
                if (!canvas || !results.plots?.varianceChartData) {
                    console.error('❌ Missing canvas or variance chart data');
                    return;
                }

                // Initialize chartInstances if not exists
                if (!window.chartInstances) {
                    window.chartInstances = {};
                }

                try {
                    const ctx = canvas.getContext('2d');
                    const chartData = results.plots.varianceChartData;
                    
                    console.log('📈 Creating variance chart with data:', chartData);

                    // Destroy existing chart if it exists
                    if (window.chartInstances.varianceChart) {
                        window.chartInstances.varianceChart.destroy();
                    }

                    // Prepare scatter plot data
                    const scatterData = chartData.dataPoints.map(point => ({
                        x: point.x,
                        y: point.y,
                        label: point.label,
                        stdDev: point.stdDev
                    }));

                    // Create the chart
                    window.chartInstances.varianceChart = new Chart(ctx, {
                        type: 'scatter',
                        data: {
                            datasets: [
                                {
                                    label: 'Standard Deviations',
                                    data: scatterData,
                                    backgroundColor: 'black',
                                    borderColor: 'white',
                                    borderWidth: 2,
                                    pointRadius: 8,
                                    pointHoverRadius: 10
                                },
                                {
                                    label: 'Pooled Std Dev',
                                    type: 'line',
                                    data: [
                                        { x: -0.5, y: chartData.pooledStd },
                                        { x: chartData.groups.length - 0.5, y: chartData.pooledStd }
                                    ],
                                    borderColor: '#0080FF',
                                    borderDash: [10, 5],
                                    borderWidth: 2,
                                    fill: false,
                                    pointRadius: 0,
                                    pointHoverRadius: 0,
                                    showLine: true
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: false
                                },
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const point = context.parsed;
                                            const dataPoint = scatterData.find(p => p.x === point.x && p.y === point.y);
                                            if (dataPoint) {
                                                return `LOT ${dataPoint.label}: ${dataPoint.stdDev.toFixed(7)}`;
                                            }
                                            return `${point.y.toFixed(7)}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Lot',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        }
                                    },
                                    type: 'linear',
                                    position: 'bottom',
                                    ticks: {
                                        // Force ticks to appear only at data point positions
                                        callback: function(value) {
                                            // Check if this value corresponds to a data point
                                            const dataPoint = chartData.dataPoints.find(point => point.x === value);
                                            if (dataPoint) {
                                                return dataPoint.label;
                                            }
                                            return '';
                                        },
                                        // Generate tick positions based on actual data points
                                        stepSize: null,
                                        maxTicksLimit: chartData.groups.length + 2
                                    },
                                    // Override tick generation to use exact data point positions
                                    afterBuildTicks: function(scale) {
                                        scale.ticks = chartData.dataPoints.map(point => ({
                                            value: point.x,
                                            label: point.label
                                        }));
                                    },
                                    grid: {
                                        display: true,
                                        drawOnChartArea: true,
                                        drawTicks: true
                                    },
                                    min: -0.5,
                                    max: chartData.groups.length - 0.5
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Std Dev',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        }
                                    },
                                    beginAtZero: true,
                                    ticks: {
                                        maxTicksLimit: 6,
                                        callback: function(value) {
                                            return value.toFixed(5);
                                        }
                                    }
                                }
                            },
                            interaction: {
                                intersect: false,
                                mode: 'point'
                            },
                            elements: {
                                point: {
                                    hoverBackgroundColor: 'black',
                                    hoverBorderColor: 'white'
                                }
                            }
                        }
                    });

                    console.log('✅ Variance chart created successfully');

                } catch (error) {
                    console.error('❌ Error creating variance chart:', error);
                }
            }

            function createTukeyChart(results) {
                console.log('🎯 createTukeyChart called');
                console.log('📊 Tukey chart data:', results.plots?.tukeyChartData);
                
                const canvas = document.getElementById('tukeyChart');
                
                if (!canvas || !results.plots?.tukeyChartData) {
                    console.error('❌ Missing canvas or tukey chart data');
                    return;
                }

                // Initialize chartInstances if not exists
                if (!window.chartInstances) {
                    window.chartInstances = {};
                }

                try {
                    const ctx = canvas.getContext('2d');
                    const chartData = results.plots.tukeyChartData;
                    
                    console.log('📈 Creating tukey chart with comparisons:', chartData.comparisons.length);

                    // Adjust canvas height based on number of comparisons for better label visibility
                    const minHeight = 300;
                    const heightPerComparison = 40;
                    const calculatedHeight = Math.max(minHeight, chartData.comparisons.length * heightPerComparison);
                    canvas.style.height = `${calculatedHeight}px`;
                    if (canvas.parentElement) {
                        canvas.parentElement.style.height = `${calculatedHeight}px`;
                    }

                    // Destroy existing chart if it exists
                    if (window.chartInstances.tukeyChart) {
                        window.chartInstances.tukeyChart.destroy();
                    }

                    // Prepare datasets for horizontal confidence intervals
                    const datasets = [];
                    
                    // Create dataset for confidence interval lines
                    chartData.comparisons.forEach((comparison, index) => {
                        // Confidence interval line
                        datasets.push({
                            type: 'line',
                            label: `CI ${comparison.label}`,
                            data: [
                                { x: comparison.lower, y: index },
                                { x: comparison.upper, y: index }
                            ],
                            borderColor: comparison.color,
                            backgroundColor: comparison.color,
                            borderWidth: 4,
                            fill: false,
                            showLine: true,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0
                        });

                        // Mean difference point
                        datasets.push({
                            type: 'scatter',
                            label: `Point ${comparison.label}`,
                            data: [{ x: comparison.difference, y: index }],
                            backgroundColor: comparison.color,
                            borderColor: 'white',
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            showLine: false
                        });

                        // End caps for confidence intervals
                        datasets.push({
                            type: 'scatter',
                            label: `Caps ${comparison.label}`,
                            data: [
                                { x: comparison.lower, y: index },
                                { x: comparison.upper, y: index }
                            ],
                            backgroundColor: comparison.color,
                            borderColor: comparison.color,
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            showLine: false
                        });
                    });

                    // Reference line at zero
                    datasets.push({
                        type: 'line',
                        label: 'Zero Reference',
                        data: [
                            { x: 0, y: -0.5 },
                            { x: 0, y: chartData.comparisons.length - 0.5 }
                        ],
                        borderColor: '#95a5a6',
                        borderDash: [10, 5],
                        borderWidth: 2,
                        fill: false,
                        showLine: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    });

                    // Create the chart
                    window.chartInstances.tukeyChart = new Chart(ctx, {
                        type: 'scatter',
                        data: {
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                zoom: {
                                    zoom: {
                                        wheel: {
                                            enabled: true,
                                            modifierKey: null
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        mode: 'y',
                                        rangeMin: {
                                            y: -0.5
                                        },
                                        rangeMax: {
                                            y: chartData.comparisons.length - 0.5
                                        }
                                    },
                                    pan: {
                                        enabled: true,
                                        mode: 'y',
                                        rangeMin: {
                                            y: -0.5
                                        },
                                        rangeMax: {
                                            y: chartData.comparisons.length - 0.5
                                        }
                                    }
                                },
                                title: {
                                    display: false
                                },
                                legend: {
                                    display: true,
                                    labels: {
                                        filter: function(legendItem) {
                                            // Only show legend for main comparison labels, not individual components
                                            return legendItem.text.includes('Point');
                                        },
                                        generateLabels: function(chart) {
                                            const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            return original.filter(item => item.text.includes('Point')).map(item => {
                                                // Clean up legend labels
                                                item.text = item.text.replace('Point ', '');
                                                return item;
                                            });
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            const point = context[0];
                                            const compIndex = Math.round(point.parsed.y);
                                            if (compIndex >= 0 && compIndex < chartData.comparisons.length) {
                                                return chartData.comparisons[compIndex].label;
                                            }
                                            return '';
                                        },
                                        label: function(context) {
                                            const point = context.parsed;
                                            const compIndex = Math.round(point.y);
                                            if (compIndex >= 0 && compIndex < chartData.comparisons.length) {
                                                const comp = chartData.comparisons[compIndex];
                                                const significant = comp.significant ? 'Significant' : 'Not Significant';
                                                return [
                                                    `Difference: ${point.x.toFixed(6)}`,
                                                    `CI: [${comp.lower.toFixed(6)}, ${comp.upper.toFixed(6)}]`,
                                                    `Status: ${significant}`
                                                ];
                                            }
                                            return `${point.x.toFixed(6)}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: chartData.xLabel,
                                        font: {
                                            size: 12,
                                            weight: 'bold'
                                        }
                                    },
                                    grid: {
                                        display: true,
                                        color: 'rgba(0, 0, 0, 0.1)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Comparison',
                                        font: {
                                            size: 12,
                                            weight: 'bold'
                                        }
                                    },
                                    type: 'linear',
                                    position: 'left',
                                    display: true,
                                    beginAtZero: false,
                                    afterBuildTicks: function(scale) {
                                        // Generate custom ticks for each comparison
                                        scale.ticks = [];
                                        for (let i = 0; i < chartData.comparisons.length; i++) {
                                            scale.ticks.push({
                                                value: i,
                                                label: chartData.comparisons[i].label || `Comparison ${i}`
                                            });
                                        }
                                    },
                                    ticks: {
                                        stepSize: 1,
                                        font: {
                                            size: 11,
                                            family: 'Arial, sans-serif',
                                            weight: 'normal'
                                        },
                                        color: '#333',
                                        padding: 8,
                                        maxRotation: 0,
                                        minRotation: 0,
                                        callback: function(value, index, ticks) {
                                            // Make sure we have access to comparisons data
                                            const ctx = this.chart.ctx;
                                            const chart = this.chart;
                                            
                                            // Round the value to ensure it's an integer
                                            const roundedValue = Math.round(value);
                                            
                                            // Check if we have valid comparison data and the value is in range
                                            if (chartData && chartData.comparisons && 
                                                roundedValue >= 0 && roundedValue < chartData.comparisons.length) {
                                                const comparison = chartData.comparisons[roundedValue];
                                                if (comparison && comparison.label) {
                                                    return comparison.label;
                                                }
                                            }
                                            return '';
                                        }
                                    },
                                    min: -0.5,
                                    max: chartData.comparisons.length - 0.5,
                                    grid: {
                                        display: true,
                                        color: 'rgba(0, 0, 0, 0.05)',
                                        lineWidth: 1
                                    }
                                }
                            },
                            interaction: {
                                intersect: false,
                                mode: 'nearest'
                            }
                        }
                    });

                    // Force update to ensure labels are displayed immediately
                    setTimeout(() => {
                        if (window.chartInstances.tukeyChart) {
                            // Debug: Log comparison data
                            console.log('📊 Tukey chart comparisons:', chartData.comparisons);
                            console.log('📊 Number of comparisons:', chartData.comparisons.length);
                            chartData.comparisons.forEach((comp, index) => {
                                console.log(`📊 Comparison ${index}:`, comp.label);
                            });
                            
                            window.chartInstances.tukeyChart.update('none');
                        }
                    }, 100);

                    // Add scroll bar functionality with mouse wheel
                    let currentViewStart = 0;
                    let itemsPerView = Math.min(10, chartData.comparisons.length); // Show 10 items at a time
                    let maxViewStart = Math.max(0, chartData.comparisons.length - itemsPerView);
                    
                    function updateChartView(viewStart) {
                        const viewEnd = Math.min(viewStart + itemsPerView, chartData.comparisons.length);
                        
                        // Update Y-axis to show only the visible range
                        window.chartInstances.tukeyChart.options.scales.y.min = viewStart - 0.5;
                        window.chartInstances.tukeyChart.options.scales.y.max = viewEnd - 0.5;
                        
                        // Update Y-axis ticks to show correct comparison labels (show all labels for continuity)
                        window.chartInstances.tukeyChart.options.scales.y.ticks.callback = function(value, index, values) {
                            // Ensure we always show the comparison labels for integer values
                            if (Number.isInteger(value) && value >= 0 && value < chartData.comparisons.length) {
                                return chartData.comparisons[value].label;
                            }
                            return '';
                        };
                        
                        // Update the chart
                        window.chartInstances.tukeyChart.update('none');
                    }
                    
                    // Add mouse wheel event for scrolling
                    canvas.addEventListener('wheel', function(event) {
                        event.preventDefault();
                        
                        if (chartData.comparisons.length <= itemsPerView) {
                            return; // No scrolling needed if all items fit
                        }
                        
                        // Determine scroll direction and step
                        const scrollStep = 1;
                        const scrollDirection = event.deltaY > 0 ? scrollStep : -scrollStep;
                        
                        // Update view start position
                        currentViewStart = Math.max(0, Math.min(maxViewStart, currentViewStart + scrollDirection));
                        
                        // Update chart view
                        updateChartView(currentViewStart);
                    });
                    
                    // Initialize with the first view if scrolling is needed
                    if (chartData.comparisons.length > itemsPerView) {
                        updateChartView(currentViewStart);
                    }
                    
                    // Store original values for reset
                    const originalItemsPerView = itemsPerView;
                    const originalHeight = 400;
                    
                    // Add event listeners for control buttons
                    document.getElementById('tukeyZoomIn').addEventListener('click', function() {
                        // Decrease items per view to zoom in (show fewer items but larger)
                        const newItemsPerView = Math.max(3, Math.floor(itemsPerView * 0.7));
                        if (newItemsPerView !== itemsPerView) {
                            itemsPerView = newItemsPerView;
                            maxViewStart = Math.max(0, chartData.comparisons.length - itemsPerView);
                            currentViewStart = Math.min(currentViewStart, maxViewStart);
                            updateChartView(currentViewStart);
                        }
                    });
                    
                    document.getElementById('tukeyZoomOut').addEventListener('click', function() {
                        // Increase items per view to zoom out (show more items but smaller)
                        const newItemsPerView = Math.min(chartData.comparisons.length, Math.ceil(itemsPerView * 1.4));
                        if (newItemsPerView !== itemsPerView) {
                            itemsPerView = newItemsPerView;
                            maxViewStart = Math.max(0, chartData.comparisons.length - itemsPerView);
                            currentViewStart = Math.min(currentViewStart, maxViewStart);
                            updateChartView(currentViewStart);
                        }
                    });
                    
                    document.getElementById('tukeyReset').addEventListener('click', function() {
                        // Reset to original view
                        itemsPerView = originalItemsPerView;
                        maxViewStart = Math.max(0, chartData.comparisons.length - itemsPerView);
                        currentViewStart = 0;
                        
                        // Reset chart to show all data if it fits, otherwise show first 10
                        if (chartData.comparisons.length <= originalItemsPerView) {
                            window.chartInstances.tukeyChart.options.scales.y.min = -0.5;
                            window.chartInstances.tukeyChart.options.scales.y.max = chartData.comparisons.length - 0.5;
                            // Reset ticks to show all labels
                            window.chartInstances.tukeyChart.options.scales.y.ticks.callback = function(value) {
                                const intValue = Math.round(value);
                                if (Number.isInteger(value) && intValue >= 0 && intValue < chartData.comparisons.length) {
                                    return chartData.comparisons[intValue].label;
                                }
                                return '';
                            };
                        } else {
                            updateChartView(currentViewStart);
                        }
                        
                        window.chartInstances.tukeyChart.update('none');
                    });

                    console.log('✅ Tukey chart created successfully');

                } catch (error) {
                    console.error('❌ Error creating tukey chart:', error);
                }
            }

            // Smart Adaptive Progress Bar System
            let progressInterval;
            let progressStartTime;
            let estimatedDuration = 15000; // Default 15 seconds
            let progressMode = 'determinate'; // 'determinate' or 'indeterminate'
            let confidenceLevel = 0; // 0-100, how confident we are in our estimation
            
            // Machine Learning-style estimation system
            window.estimateProcessingTime = function(dataSize) {
                const historyKey = 'processing_time_history';
                let history = [];
                try {
                    history = JSON.parse(localStorage.getItem(historyKey) || '[]');
                } catch (e) {
                    console.warn('Failed to load processing time history:', e);
                }
                
                if (history.length === 0) {
                    // No history - use indeterminate mode
                    progressMode = 'indeterminate';
                    confidenceLevel = 0;
                    estimatedDuration = 10000; // Default fallback
                    console.log('🔄 No history available - using indeterminate progress mode');
                    return estimatedDuration;
                }
                
                // Calculate weighted estimation based on similar data sizes
                const recentHistory = history.filter(h => Date.now() - h.timestamp < 7 * 24 * 60 * 60 * 1000); // Last 7 days
                const similarSizeData = recentHistory.filter(h => {
                    const sizeDiff = Math.abs(h.dataSize - dataSize) / Math.max(h.dataSize, dataSize);
                    return sizeDiff <= 0.5; // Within 50% of data size
                });
                
                if (similarSizeData.length >= 3) {
                    // High confidence - use weighted average
                    progressMode = 'determinate';
                    const weights = similarSizeData.map((_, i) => Math.pow(0.9, similarSizeData.length - 1 - i)); // Recent data has higher weight
                    const weightedSum = similarSizeData.reduce((sum, h, i) => sum + h.time * weights[i], 0);
                    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                    estimatedDuration = (weightedSum / totalWeight) * 1.2; // 20% buffer
                    confidenceLevel = Math.min(95, 60 + similarSizeData.length * 5);
                    console.log(`📊 High confidence estimation: ${estimatedDuration}ms (confidence: ${confidenceLevel}%)`);
                } else if (recentHistory.length >= 2) {
                    // Medium confidence - use correlation
                    progressMode = 'determinate';
                    const avgTimePerPoint = recentHistory.reduce((sum, h) => sum + (h.time / h.dataSize), 0) / recentHistory.length;
                    estimatedDuration = dataSize * avgTimePerPoint * 1.5; // 50% buffer
                    confidenceLevel = Math.min(75, 30 + recentHistory.length * 10);
                    console.log(`📈 Medium confidence estimation: ${estimatedDuration}ms (confidence: ${confidenceLevel}%)`);
                } else {
                    // Low confidence - use indeterminate with rough estimate
                    progressMode = 'indeterminate';
                    const lastTime = history[history.length - 1].time;
                    estimatedDuration = lastTime * 1.8; // Very conservative
                    confidenceLevel = 25;
                    console.log(`🤔 Low confidence - using indeterminate mode with rough estimate: ${estimatedDuration}ms`);
                }
                
                return estimatedDuration;
            };

            window.startProgressBar = function() {
                const progressBar = document.querySelector('.progress-bar');
                if (!progressBar) return;
                
                // Reset progress
                progressBar.style.width = '0%';
                progressBar.style.animation = 'none';
                progressBar.textContent = '';
                
                // Clear any existing interval
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                
                progressStartTime = Date.now();
                
                if (progressMode === 'indeterminate') {
                    // Indeterminate animation - spinning/pulsing
                    progressBar.style.background = '#28A745';
                    progressBar.style.animation = 'indeterminateProgress 2s ease-in-out infinite';
                    progressBar.textContent = 'Processing...';
                    console.log('🔄 Starting indeterminate progress animation');
                } else {
                    // Determinate progress with smart timing
                    progressBar.style.background = '#28A745';
                    progressBar.style.transition = 'width 0.3s ease';
                    
                    progressInterval = setInterval(() => {
                        const elapsed = Date.now() - progressStartTime;
                        let progress;
                        
                        if (elapsed < estimatedDuration * 0.8) {
                            // First 80% of estimated time - logarithmic progress (slower start, faster middle)
                            const normalizedTime = elapsed / (estimatedDuration * 0.8);
                            progress = 80 * (1 - Math.exp(-3 * normalizedTime)); // Exponential approach to 80%
                        } else if (elapsed < estimatedDuration) {
                            // Last 20% - slow down to 95%
                            const normalizedTime = (elapsed - estimatedDuration * 0.8) / (estimatedDuration * 0.2);
                            progress = 80 + 15 * normalizedTime; // Linear from 80% to 95%
                        } else {
                            // Overtime - slowly approach 98% but never quite reach 100%
                            const overtime = elapsed - estimatedDuration;
                            progress = 95 + 3 * (1 - Math.exp(-overtime / (estimatedDuration * 0.5))); // Asymptotic approach to 98%
                        }
                        
                        progress = Math.min(progress, 98); // Never show 100% until actually complete
                        progressBar.style.width = progress + '%';
                        progressBar.textContent = `${Math.round(progress)}%`;
                        
                        // Show confidence in tooltip
                        progressBar.title = `Confidence: ${confidenceLevel}% | Estimated: ${Math.round(estimatedDuration/1000)}s`;
                    }, 100);
                    
                    console.log(`📊 Starting determinate progress (confidence: ${confidenceLevel}%)`);
                }
            };

            window.stopProgressBar = function() {
                const progressBar = document.querySelector('.progress-bar');
                if (!progressBar) return;
                
                // Record actual processing time for learning
                if (progressStartTime) {
                    const actualTime = Date.now() - progressStartTime;
                    console.log(`✅ Processing completed in ${actualTime}ms`);
                    
                    // Update estimation model
                    if (window.updateProcessingTimeEstimate) {
                        // Get data size from last analysis
                        const lastDataSize = window.lastAnalyzedDataSize || 100;
                        window.updateProcessingTimeEstimate(lastDataSize, actualTime);
                    }
                }
                
                // Clear interval
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                
                // Complete animation
                progressBar.style.animation = 'none';
                progressBar.style.transition = 'width 0.5s ease';
                progressBar.style.width = '100%';
                progressBar.textContent = '100%';
                progressBar.title = 'Analysis Complete!';
                
                // Reset after delay
                setTimeout(() => {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '';
                    progressBar.title = '';
                }, 1200);
            };

            // Enhanced learning system for better future predictions
            window.updateProcessingTimeEstimate = function(dataSize, actualTime) {
                const historyKey = 'processing_time_history';
                let history = [];
                try {
                    history = JSON.parse(localStorage.getItem(historyKey) || '[]');
                } catch (e) {
                    history = [];
                }
                
                // Add new measurement with metadata
                const newEntry = {
                    dataSize: dataSize,
                    time: actualTime,
                    timestamp: Date.now(),
                    confidence: confidenceLevel,
                    estimatedTime: estimatedDuration,
                    accuracy: Math.abs(actualTime - estimatedDuration) / estimatedDuration // Prediction accuracy
                };
                
                history.push(newEntry);
                
                // Keep only recent and relevant data (max 100 entries, last 30 days)
                const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
                history = history.filter(h => h.timestamp > thirtyDaysAgo).slice(-100);
                
                // Save updated history
                try {
                    localStorage.setItem(historyKey, JSON.stringify(history));
                    console.log(`📈 Learning: ${actualTime}ms for ${dataSize} points (accuracy: ${Math.round((1-newEntry.accuracy)*100)}%)`);
                } catch (e) {
                    console.warn('Failed to save processing time history:', e);
                }
            };
        });
    </script>
</body>
</html>












